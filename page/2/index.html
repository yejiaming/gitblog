<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <title>
    yjm
    
</title>
    <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="browsermode" content="application">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="yjm">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="msapplication-navbutton-color" content="#666666">
<meta name= "format-detection" content="telephone=no" />
<meta name="keywords" content="nlvi, Nlvi" />





<link rel="stylesheet" href="/style/style.css">
<script src="/script/jquery.min.js"></script>
<script>
    var CONFIG = {
        title: "yjm",
        author: "arvin ye",
        lightbox: true,
        animate: true
    }
</script>



    <link rel="stylesheet" href="/lightbox/css/lightbox.min.css">




    <link rel="stylesheet" href="/syuanpi/syuanpi.min.css">









    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


</head>
<body>
    <div class="progress">
    <div class="progress-inner"></div>
</div>
    <div class="body">
    <div class="tagcloud-mask"></div>  
<div class="tagcloud" id="tagcloud">
    <div class="tagcloud-inner">
        <a href="/tags/AMD-UMD-CMD-commonJS-ES6-module/" style="font-size: 14px;">AMD - UMD - CMD - commonJS - ES6 module</a> <a href="/tags/CSSOM视图模式/" style="font-size: 14px;">CSSOM视图模式</a> <a href="/tags/ES6解构赋值/" style="font-size: 14px;">ES6解构赋值</a> <a href="/tags/Generator/" style="font-size: 14px;">Generator</a> <a href="/tags/JS执行顺序/" style="font-size: 14px;">JS执行顺序</a> <a href="/tags/Promise/" style="font-size: 14px;">Promise</a> <a href="/tags/apply/" style="font-size: 14px;">apply</a> <a href="/tags/asyn-await/" style="font-size: 14px;">asyn...await</a> <a href="/tags/bind/" style="font-size: 14px;">bind</a> <a href="/tags/call/" style="font-size: 14px;">call</a> <a href="/tags/contenteditable/" style="font-size: 14px;">contenteditable</a> <a href="/tags/echarts/" style="font-size: 14px;">echarts</a> <a href="/tags/interator/" style="font-size: 14px;">interator</a> <a href="/tags/scroll/" style="font-size: 14px;">scroll</a> <a href="/tags/sticky/" style="font-size: 14px;">sticky</a> <a href="/tags/vuex/" style="font-size: 14px;">vuex</a> <a href="/tags/webkit/" style="font-size: 14px;">webkit</a> <a href="/tags/代理/" style="font-size: 14px;">代理</a> <a href="/tags/创建对象/" style="font-size: 14px;">创建对象</a> <a href="/tags/原型链/" style="font-size: 14px;">原型链</a> <a href="/tags/变量声名/" style="font-size: 14px;">变量声名</a> <a href="/tags/回调/" style="font-size: 14px;">回调</a> <a href="/tags/块级作用域/" style="font-size: 14px;">块级作用域</a> <a href="/tags/垂直居中/" style="font-size: 14px;">垂直居中</a> <a href="/tags/层叠水平/" style="font-size: 14px;">层叠水平</a> <a href="/tags/性能/" style="font-size: 14px;">性能</a> <a href="/tags/排序/" style="font-size: 14px;">排序</a> <a href="/tags/数组/" style="font-size: 14px;">数组</a> <a href="/tags/数组遍历/" style="font-size: 14px;">数组遍历</a> <a href="/tags/正则表达式/" style="font-size: 14px;">正则表达式</a> <a href="/tags/线程/" style="font-size: 14px;">线程</a> <a href="/tags/继承-原型链/" style="font-size: 14px;">继承 - 原型链</a> <a href="/tags/轮播/" style="font-size: 14px;">轮播</a> <a href="/tags/闭包/" style="font-size: 14px;">闭包</a> <a href="/tags/隐式转换/" style="font-size: 14px;">隐式转换</a>
    </div>
</div>
    <header class="header" id="header">
    <div class="title syuanpi tvIn">
    <div class="table">
        <div class="connect">
            <div class="connect-inner">
                <span><a href="/">yjm</a></span>
                
            </div>
        </div>
    </div>
</div>
    <nav class="main-nav syuanpi tvIn">
<div class="table">

    <ul class="menu">
        
        <li class="menu-item">
            <a href="javascript:;" id="search">
                <span>搜索</span>
                
                    <span class="menu-item-label">search</span>
                
            </a>
        </li>
        
        
        
            <li class="menu-item">
                <a href="/">
                    <span>文章</span>
                    
                        <span class="menu-item-label">article</span>
                    
                </a>
            </li>
        
        
        
            <li class="menu-item">
                <a href="/archives">
                    <span>归档</span>
                    
                        <span class="menu-item-label">archives</span>
                    
                </a>
            </li>
        
        
        
            <li class="menu-item">
                <a href="javascript:;" id="tags">
                    <span>标签</span>
                    
                        <span class="menu-item-label">tags</span>
                    
                </a>
            </li>
        
        
        
            <li class="menu-item">
                <a href="/about">
                    <span>关于</span>
                    
                        <span class="menu-item-label">about</span>
                    
                </a>
            </li>
        
        
        
            <li class="menu-item">
                <a href="/atom.xml">
                    <span>订阅</span>
                    
                        <span class="menu-item-label">RSS</span>
                    
                </a>
            </li>
        
        
    </ul>

</div>
</nav>
</header>
<div class="mobile-header">
    <div class="mobile-header-body">
        <div class="mobile-header-list">
            
            
                <div class="mobile-nav-item">
                    <a href="/">
                        <span>文章</span>
                        
                            <span class="menu-item-label">article</span>
                        
                    </a>
                </div>
            
            
            
                <div class="mobile-nav-item">
                    <a href="/archives">
                        <span>归档</span>
                        
                            <span class="menu-item-label">archives</span>
                        
                    </a>
                </div>
            
            
            
                <div class="mobile-nav-item inner-cloud">
                    <div class="mobile-nav-tag">
                        <a href="javascript:;" id="mobile-tags">
                            <span>标签</span>
                            
                                <span class="menu-item-label">tags</span>
                            
                        </a>
                    </div>
                    <div class="mobile-nav-tagcloud">
                        <div class="mobile-tagcloud-inner">
                            <a href="/tags/AMD-UMD-CMD-commonJS-ES6-module/" style="font-size: 14px;">AMD - UMD - CMD - commonJS - ES6 module</a> <a href="/tags/CSSOM视图模式/" style="font-size: 14px;">CSSOM视图模式</a> <a href="/tags/ES6解构赋值/" style="font-size: 14px;">ES6解构赋值</a> <a href="/tags/Generator/" style="font-size: 14px;">Generator</a> <a href="/tags/JS执行顺序/" style="font-size: 14px;">JS执行顺序</a> <a href="/tags/Promise/" style="font-size: 14px;">Promise</a> <a href="/tags/apply/" style="font-size: 14px;">apply</a> <a href="/tags/asyn-await/" style="font-size: 14px;">asyn...await</a> <a href="/tags/bind/" style="font-size: 14px;">bind</a> <a href="/tags/call/" style="font-size: 14px;">call</a> <a href="/tags/contenteditable/" style="font-size: 14px;">contenteditable</a> <a href="/tags/echarts/" style="font-size: 14px;">echarts</a> <a href="/tags/interator/" style="font-size: 14px;">interator</a> <a href="/tags/scroll/" style="font-size: 14px;">scroll</a> <a href="/tags/sticky/" style="font-size: 14px;">sticky</a> <a href="/tags/vuex/" style="font-size: 14px;">vuex</a> <a href="/tags/webkit/" style="font-size: 14px;">webkit</a> <a href="/tags/代理/" style="font-size: 14px;">代理</a> <a href="/tags/创建对象/" style="font-size: 14px;">创建对象</a> <a href="/tags/原型链/" style="font-size: 14px;">原型链</a> <a href="/tags/变量声名/" style="font-size: 14px;">变量声名</a> <a href="/tags/回调/" style="font-size: 14px;">回调</a> <a href="/tags/块级作用域/" style="font-size: 14px;">块级作用域</a> <a href="/tags/垂直居中/" style="font-size: 14px;">垂直居中</a> <a href="/tags/层叠水平/" style="font-size: 14px;">层叠水平</a> <a href="/tags/性能/" style="font-size: 14px;">性能</a> <a href="/tags/排序/" style="font-size: 14px;">排序</a> <a href="/tags/数组/" style="font-size: 14px;">数组</a> <a href="/tags/数组遍历/" style="font-size: 14px;">数组遍历</a> <a href="/tags/正则表达式/" style="font-size: 14px;">正则表达式</a> <a href="/tags/线程/" style="font-size: 14px;">线程</a> <a href="/tags/继承-原型链/" style="font-size: 14px;">继承 - 原型链</a> <a href="/tags/轮播/" style="font-size: 14px;">轮播</a> <a href="/tags/闭包/" style="font-size: 14px;">闭包</a> <a href="/tags/隐式转换/" style="font-size: 14px;">隐式转换</a>
                        </div>
                    </div>
                </div>
            
            
            
                <div class="mobile-nav-item">
                    <a href="/about">
                        <span>关于</span>
                        
                            <span class="menu-item-label">about</span>
                        
                    </a>
                </div>
            
            
            
                <div class="mobile-nav-item">
                    <a href="/atom.xml">
                        <span>订阅</span>
                        
                            <span class="menu-item-label">RSS</span>
                        
                    </a>
                </div>
            
            
        </div>
    </div>
    <div class="mobile-header-nav">
        <div class="mobile-header-item" id="mobile-left">
            <div class="header-menu-item">
                <span class="header-menu-line"></span>
            </div>
        </div>
        <h1 class="mobile-header-title">
            <a href="/">yjm</a>
        </h1>
        <div class="mobile-header-item"></div>
    </div>
</div>

    <div class="container">
        <main class="main" id="main">
            
    

<section class="posts">
    
        
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年8月22日</span>
                
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                <a href="/2017/08/22/从输入URL地址到显示完整的页面Webkit都做了哪些事情/">从输入URL地址到显示完整的页面Webkit都做了哪些事情</a>
            
            </h1>
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                
                    <h1 id="从输入URL地址到显示完整的页面Webkit都做了哪些事情"><a href="#从输入URL地址到显示完整的页面Webkit都做了哪些事情" class="headerlink" title="从输入URL地址到显示完整的页面Webkit都做了哪些事情"></a>从输入URL地址到显示完整的页面Webkit都做了哪些事情</h1><h3 id="从输入地址到获取到数据的流程"><a href="#从输入地址到获取到数据的流程" class="headerlink" title="从输入地址到获取到数据的流程"></a>从输入地址到获取到数据的流程</h3><p>1、输入URL地址,如：<a href="http://www.yejm16361.com/demo/index.html。" target="_blank" rel="external">http://www.yejm16361.com/demo/index.html。</a></p>
<p>2、DNS解析URL地址中的域名返回IP地址（如果是主机名是IP地址就跳过该步骤）。</p>
<p>3、 建立TCP连接，这就是经典的<strong>TCP连接中的三次握手</strong>，总的来说作用就是为了<strong>在不可靠信道上能够可靠的传输</strong>。</p>
<p>4、浏览器向 web 服务器发送一个 HTTP 请求命令，如：GET/demo/index.html HTTP/1.1。</p>
<p>5、浏览器向 web 服务器发送请求头信息。</p>
<p>6、Web服务器应答，如：HTTP/1.1 200 OK，包含<strong>应答协议版本号和状态码</strong>。</p>
<p>7、Web服务器发送应答头信息。</p>
<p>8、Web服务器向浏览器发送数据。</p>
<p>9、Web服务器关闭TCP连接（如果浏览器或者服务器在其头信息加入了这行代码：<strong>Connection:keep-alive就延时跳过该步骤，超时仍然会关闭TCP连接，超时时间一般是5秒或15秒</strong>）。<br>
                    
            
        
            <p class="content-link">
                <a href="/2017/08/22/从输入URL地址到显示完整的页面Webkit都做了哪些事情/#more">
                    <span class="iconfont icon-right">继续阅读</span>
                </a>
            </p>
        
        </div>
        
    </article>
    

    
        
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年8月22日</span>
                
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                <a href="/2017/08/22/ES6解构赋值/">ES6解构赋值</a>
            
            </h1>
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                
                    <h1 id="ES6解构赋值"><a href="#ES6解构赋值" class="headerlink" title="ES6解构赋值"></a>ES6解构赋值</h1><p>ES6变量的解构赋值本质上是“模式匹配”,只要等号两边的模式相同，左边的变量就会被赋予匹配的右边的值，如果匹配不成功变量的值就等于undefined</p>
<p>##数组的解构赋值<br>ES6中只要某种数据有Iterator接口（也就是可以循环迭代），都可以进行数组的解构赋值。<br><strong>Example1</strong>：数组的解构</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> [d,[e],...f] = [<span class="number">4</span>,[<span class="number">5</span>],<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">//结果为1，b,c结果是2，3</span></div><div class="line"><span class="built_in">console</span>.log(e,f) <span class="comment">//e结果为5，f的结果是一个数组：[6,7,8]</span></div></pre></td></tr></table></figure>
<p><strong>Example2</strong>：Set解构赋值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x,y] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>]);</div><div class="line"><span class="built_in">console</span>.log(x,y);   <span class="comment">//结果为1和2</span></div></pre></td></tr></table></figure>
                    
            
        
            <p class="content-link">
                <a href="/2017/08/22/ES6解构赋值/#more">
                    <span class="iconfont icon-right">继续阅读</span>
                </a>
            </p>
        
        </div>
        
    </article>
    

    
        
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年8月22日</span>
                
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                <a href="/2017/08/22/ES5和ES6中的变量声明提升/">ES5和ES6中的变量声明提升</a>
            
            </h1>
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                
                    <p>##ES5和ES6中的变量声明提升</p>
<p><strong>Example1</strong>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a=<span class="number">2</span>;</div><div class="line"><span class="keyword">var</span> a;</div><div class="line"><span class="built_in">console</span>.log( a );   <span class="comment">//结果为2</span></div></pre></td></tr></table></figure>
<p><strong>Example2</strong>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log( a );   <span class="comment">//结果是undefined</span></div><div class="line"><span class="keyword">var</span> a=<span class="number">2</span>;</div></pre></td></tr></table></figure>
                    
            
        
            <p class="content-link">
                <a href="/2017/08/22/ES5和ES6中的变量声明提升/#more">
                    <span class="iconfont icon-right">继续阅读</span>
                </a>
            </p>
        
        </div>
        
    </article>
    

    
        
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年8月22日</span>
                
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                <a href="/2017/08/22/vuex总结/">vuex总结</a>
            
            </h1>
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                
                    <h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><ul>
<li>作用：相当于vue中的data，用于存储状态，是<strong>唯一数据源</strong>，而是只读，不能做直接修改。</li>
<li>语法：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  state: &#123;</div><div class="line">    text:<span class="string">'hello world'</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li>调用：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法1</span></div><div class="line">store.state.text</div><div class="line"><span class="comment">// 方法2（需要使用vue.use注入）</span></div><div class="line"><span class="keyword">this</span>.$store.state.text</div><div class="line"><span class="comment">// 方法3，通过辅助函数mapState</span></div><div class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    computed: &#123;</div><div class="line">        <span class="comment">// 使用ES6的扩展运算符来达到将state释放出来</span></div><div class="line">        ...mapState([</div><div class="line">          <span class="comment">// 映射 this.text 为 store.state.text</span></div><div class="line">          <span class="string">'text'</span></div><div class="line">        ])</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意：</strong>如果一般state初始化时最好就设置好所需属性，如果真的需要动态需改某一个属性，可以如下：<br>1）Vue.set(obj, ‘newProp’, 123)<br>2）state.obj = { …state.obj, newProp: 123 }</p>
<h2 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h2><ul>
<li>作用：相当于vue中的computed，作用也是类似的。</li>
<li>语法：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  state: &#123;</div><div class="line">    text:<span class="string">'hello world'</span></div><div class="line">  &#125;,</div><div class="line">  getters: &#123;</div><div class="line">    <span class="comment">// 第一个参数固定是state对象，第二个参数固定是getters对象</span></div><div class="line">    getText: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> state.text + <span class="string">' xiaoming'</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// getters方法中调用getters方法</span></div><div class="line">    getGettersText: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> getters.getText;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// getters方法返回一个函数</span></div><div class="line">    getFuncText: <span class="function">(<span class="params">state,getters</span>) =&gt;</span> (name) =&gt; &#123;</div><div class="line">        <span class="keyword">return</span> state.text + <span class="string">' '</span> + name;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li>调用：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法1</span></div><div class="line">store.getters.getText</div><div class="line"><span class="comment">// 方法2</span></div><div class="line"><span class="keyword">this</span>.$store.getters.getText</div><div class="line"><span class="comment">// 方法3，通过辅助函数mapGetters</span></div><div class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    computed: &#123;</div><div class="line">        ...mapGetters([</div><div class="line">            <span class="string">'getText'</span>,</div><div class="line">            <span class="string">'getGettersText'</span>,</div><div class="line">            <span class="string">'getFuncText'</span></div><div class="line">        ])</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="mutation"><a href="#mutation" class="headerlink" title="mutation"></a>mutation</h2><ul>
<li><p>作用：相当于vue中data对象的的set方法，是唯一可以改变state数据的方式，定位是<strong>同步改变</strong>，即在mutation的方法中不支持异步逻辑，这个的具体原因是因为mutation类似于事件监听的回调函数，而任何在回调函数中进行的状态的改变都是不可追踪的。</p>
</li>
<li><p>语法：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  state: &#123;</div><div class="line">    text:<span class="string">'hello world'</span></div><div class="line">  &#125;,</div><div class="line">  mutations: &#123;</div><div class="line">    <span class="comment">// 第一个参数固定是state，剩下还可以再传入一个或0个参数（也叫载荷），这个载荷参数一般是对象，方便传入多个值</span></div><div class="line">    changeText (state, payload) &#123;</div><div class="line">      <span class="comment">// 变更状态</span></div><div class="line">      state.text = <span class="string">'welcome'</span> + payload.name;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li>调用：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法1，只是第二个参数是载荷</span></div><div class="line">store.commit(<span class="string">'changeText'</span>, &#123;</div><div class="line">    name: <span class="string">'xiaoye'</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">// 方法2，相当于整个对象都是载荷</span></div><div class="line">store.commit(&#123;</div><div class="line">    type: <span class="string">'changeText'</span>,</div><div class="line">    name: <span class="string">'xiaoye'</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">// 方法3</span></div><div class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'changeText'</span>, &#123;</div><div class="line">    name: <span class="string">'xiaoye'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 方法4，依赖辅助函数mapMutations </span></div><div class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  methods: &#123;</div><div class="line">  <span class="comment">// 将this.changeText(&#123;name: 'xiaoye'&#125;)映射为this.$store.commit('changeText', &#123;name: 'xiaoye'&#125;);</span></div><div class="line">    ...mapMutations([</div><div class="line">      <span class="string">'changeText'</span></div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><ul>
<li><p>作用：相当于vue中的method，<strong>不能</strong>直接修改state，<strong>只能</strong>通过调用mutation中的方法间接改变state，定位是<strong>异步改变</strong>，当然也可以同步，如果是需要异步改变的逻辑建议写在action中，其实用过action就知道，其实就相当于把本来属于vue中的method中的方法放到vuex中的action中来而已，只是说公共的异步请求不再用写那么多份在不同的method中，只需要写一份放在action中即可。</p>
</li>
<li><p>语法：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  state: &#123;</div><div class="line">    text:<span class="string">'hello world'</span></div><div class="line">  &#125;,</div><div class="line">  mutations: &#123;</div><div class="line">    <span class="comment">// 第一个参数固定是state，剩下还可以再传入一个或0个参数（也叫载荷），这个载荷参数一般是对象，方便传入多个值</span></div><div class="line">    changeText (state, payload) &#123;</div><div class="line">      <span class="comment">// 变更状态</span></div><div class="line">      state.text = <span class="string">'welcome'</span> + payload.name;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  actions: &#123;</div><div class="line">    <span class="comment">// 第一个参数是固定的一个类似store的实例，具有和store实例相同方法和属性，即可以直接调用state，getters，commit，dispatch等；第二个参数同mutations一样，是载荷</span></div><div class="line">    asynChangeText (context, payload) &#123;</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">          context.commit(<span class="string">'changeText'</span>, payload.asynName)</div><div class="line">        &#125;, <span class="number">1000</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li>调用：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法1</span></div><div class="line">store.dispatch(<span class="string">'asynChangeText'</span>, &#123;</div><div class="line">  asynName: <span class="string">'xiaoMing'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 方法2</span></div><div class="line">store.dispatch(&#123;</div><div class="line">  type: <span class="string">'asynChangeText'</span>,</div><div class="line">  asynName: <span class="string">'xiaoMing'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 方法3</span></div><div class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'asynChangeText'</span>, &#123;</div><div class="line">    asynName: <span class="string">'xiaoMing'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 方法4，依赖辅助函数mapActions</span></div><div class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  <span class="comment">// 用法同 mutation 一样</span></div><div class="line">  methods: &#123;</div><div class="line">    ...mapActions([</div><div class="line">      <span class="string">'asynChangeText'</span></div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><ul>
<li><p>作用：将<strong>state模块化和嵌套子模块化</strong>，避免state过大，而变得臃肿，不方便管理，每一个模块都包含完整的state、actions、mutations、getters。</p>
</li>
<li><p>语法1（默认命名空间）：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> ** 模块化（默认命名空间）</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">const</span> moduleA = &#123;</div><div class="line">  state: &#123;</div><div class="line">    a: <span class="number">1</span>,</div><div class="line">  &#125;,</div><div class="line">  mutations: &#123;</div><div class="line">    <span class="comment">// 该state包含的是本模块自己以及子模块的state</span></div><div class="line">    setA (state, payload) &#123;&#125;</div><div class="line">  &#125;,</div><div class="line">  actions: &#123;</div><div class="line">    <span class="comment">// 该context除包含本模块自己以及子模块的属性和方法外，还另外多包含rootGetters和rootState两个属性根模块（moduleA）的state和getter</span></div><div class="line">     getAsynA (context, payload) &#123;&#125;</div><div class="line">  &#125;,</div><div class="line">  getters: &#123;</div><div class="line">    <span class="comment">// 这里的rootState和rootGetter等同于根模块（moduleA）的state和getter</span></div><div class="line">    getA (state, getters, rootState, rootGetter) &#123;&#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 两个子模块</span></div><div class="line">  modules: &#123;</div><div class="line">    moduleB,</div><div class="line">    moduleC</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 和moduleA模块一样，只是rootState和rootGetter依然表示moduleA这个跟模块而已</span></div><div class="line"><span class="keyword">const</span> moduleB = &#123;</div><div class="line">  state: &#123;  &#125;,</div><div class="line">  mutations: &#123; ... &#125;,</div><div class="line">  actions: &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 同moduleB</span></div><div class="line"><span class="keyword">const</span> moduleC = &#123;</div><div class="line">  state: &#123; ... &#125;,</div><div class="line">  mutations: &#123; ... &#125;,</div><div class="line">  actions: &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(moduleA)</div></pre></td></tr></table></figure>
<p><strong>注意：</strong>在默认的命名空间中：<br>1）所有的模块和子模块的mutations和actions都是包含在全局中的，也叫在<strong>全局命名空间</strong>中。也就是说如果不同的模块中有相同的actions或者mutations是会存在重复注册挂载到全局中的情况的，只不过他们<strong>不是覆盖而是追加</strong>的关系而已，被调用的顺讯也是按照<strong>模块的注册顺序递归调用</strong>的。</p>
<p>2）所有模块和子模块的getters都是包含在全局中的，不过不同的是如果出现不同模块之间重名的情况，不是追加而是<strong>先到先得</strong>，即哪一个模块先注册，即使用谁的。</p>
<p>3）而state是仍然是划分模块的，外部如果要调用，调用方式也是按照<strong>模块的层级路径</strong>来调用的。即：<strong>moduleA的状态：store.state；moduleB的状态：store.state.moduleB</strong>。</p>
<ul>
<li>调用：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 调用state，方法1</span></div><div class="line">store.state.a</div><div class="line">store.state.moduleB.b</div><div class="line"><span class="comment">// 调用state，方法2</span></div><div class="line"><span class="keyword">this</span>.$store.state.a</div><div class="line"><span class="keyword">this</span>.$store.state.moduleB.b</div><div class="line"><span class="comment">// 调用state，方法3</span></div><div class="line"><span class="keyword">import</span> &#123;mapState&#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    computed: &#123;</div><div class="line">        ...mapState([</div><div class="line">            <span class="string">'a'</span>,        <span class="comment">// 是moduleA的state</span></div><div class="line">            <span class="string">'moduleB'</span>,   <span class="comment">// moduleB是一个对象，包含自己以及子模块的state</span></div><div class="line">            <span class="string">'c'</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.a.moduleC.c <span class="comment">// moduleC模块下的state可以通过这种方法的形式返回值</span></div><div class="line">        ])</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用getter，方法1</span></div><div class="line">store.getters.getA</div><div class="line">store.getters.getB</div><div class="line"><span class="comment">// 调用getter，方法2</span></div><div class="line"><span class="keyword">this</span>.$store.getters.getA</div><div class="line"><span class="keyword">this</span>.$store.getters.getB</div><div class="line"><span class="comment">// 调用getter，方法3</span></div><div class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    computed: &#123;</div><div class="line">        ...mapGetters([</div><div class="line">            <span class="string">'getA'</span>,</div><div class="line">            <span class="string">'getB'</span></div><div class="line">        ])</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用mutations，方法1，和getter相同点都是挂载在全局中，不同点是不同模块中存在相同名称是会按顺序触发的</span></div><div class="line">store.commit(<span class="string">'setA'</span>)</div><div class="line">store.commit(<span class="string">'setB'</span>)</div><div class="line"><span class="comment">// 调用mutations，方法2</span></div><div class="line">store.commit(&#123;</div><div class="line">    type: <span class="string">'setA'</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">// 调用mutations，方法3</span></div><div class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'setA'</span>)</div><div class="line"><span class="comment">// 调用mutations，方法4</span></div><div class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  methods: &#123;</div><div class="line">    ...mapMutations([</div><div class="line">      <span class="string">'setA'</span></div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用actions，同mutations一样</span></div></pre></td></tr></table></figure>
<ul>
<li>语法2（命名空间）：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> ** 模块化（命名空间）</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">const</span> moduleA = &#123;</div><div class="line">  namespaced: <span class="literal">true</span>,</div><div class="line">  state: &#123;</div><div class="line">    a: <span class="number">1</span>,</div><div class="line">  &#125;,</div><div class="line">  mutations: &#123;</div><div class="line">    <span class="comment">// 该state包含的是本模块自己以及子模块的state</span></div><div class="line">    setA (state, payload) &#123;&#125;</div><div class="line">  &#125;,</div><div class="line">  actions: &#123;</div><div class="line">    <span class="comment">// 该context除包含本模块自己以及子模块的属性和方法外，还另外多包含rootGetters和rootState两个属性根模块（moduleA）的state和getter</span></div><div class="line">     getAsynA (context, payload) &#123;&#125;</div><div class="line">  &#125;,</div><div class="line">  getters: &#123;</div><div class="line">    <span class="comment">// 这里的rootState和rootGetter等同于根模块（moduleA）的state和getter</span></div><div class="line">    getA (state, getters, rootState, rootGetter) &#123;&#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 两个子模块</span></div><div class="line">  modules: &#123;</div><div class="line">    moduleB,</div><div class="line">    moduleC</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 和moduleA模块一样，只是rootState和rootGetter依然表示moduleA这个跟模块而已</span></div><div class="line"><span class="keyword">const</span> moduleB = &#123;</div><div class="line">  <span class="comment">//  namespaced: true, // 这里如果不设置命名空间的话那moduleC就继承父命名空间</span></div><div class="line">  state: &#123;  &#125;,</div><div class="line">  mutations: &#123; ... &#125;,</div><div class="line">  actions: &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 同moduleB</span></div><div class="line"><span class="keyword">const</span> moduleC = &#123;</div><div class="line">  namespaced: <span class="literal">true</span>,</div><div class="line">  state: &#123; ... &#125;,</div><div class="line">  mutations: &#123; ... &#125;,</div><div class="line">  actions: &#123; ... &#125;,</div><div class="line">  modules: &#123;</div><div class="line">        moduleD: &#123;</div><div class="line">            namespaced: <span class="literal">true</span>,</div><div class="line">            state: &#123;</div><div class="line">                d: <span class="number">1</span>,</div><div class="line">            &#125;,</div><div class="line">            mutations: &#123;&#125;,</div><div class="line">            actions: &#123;&#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(moduleA)</div></pre></td></tr></table></figure>
<p><strong>注意：</strong>在命名空间中：<br>1）所有的模块和子模块的mutations、actions、getters都是包含在<strong>各自的命名空间或父命名空间中</strong>，即<strong>自动根据模块注册的路径调整命名</strong>。</p>
<p>2）而state不受影响，因为默认state也已经是层级嵌套的了。</p>
<ul>
<li>调用</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 调用state，方法4（前三个方法和默认命名空间类似）</span></div><div class="line">computed: &#123;</div><div class="line">  ...mapState(<span class="string">'moduleC/moduleD'</span>, &#123;</div><div class="line">    d: <span class="function"><span class="params">state</span> =&gt;</span> state.d</div><div class="line">  &#125;),</div><div class="line">  ...mapState(<span class="string">'moduleC/moduleD'</span>, [<span class="string">'d'</span>]) <span class="comment">// 这两种是一样的，只是写法不同</span></div><div class="line">&#125;,</div><div class="line"><span class="comment">// 调用state，方法5（通过辅助函数createNamespacedHelpers）</span></div><div class="line"><span class="keyword">import</span> &#123; createNamespacedHelpers &#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</div><div class="line"><span class="keyword">const</span> &#123; mapState &#125; = createNamespacedHelpers(<span class="string">'moduleC/moduleD'</span>);</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  computed: &#123;</div><div class="line">    <span class="comment">// 在 `moduleC/moduleD` 中查找</span></div><div class="line">    ...mapState(&#123;</div><div class="line">      d: <span class="function"><span class="params">state</span> =&gt;</span> state.d</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 其他的getter、mutations、actions也是和state类似的以上的方法</span></div></pre></td></tr></table></figure>
<h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><ul>
<li><p>作用：plugins 是vuex中的一个函数，一般配合 subscribe 函数实现类似于拦截器的效果，而且是一个成功之后的拦截器，是每次 mutation 调用成功之后的钩子，它接收store 实例作为作为唯一的参数。</p>
</li>
<li><p>语法：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> myPlugin = <span class="function"><span class="params">store</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// mutation 的格式为：&#123; type, payload &#125;，通过这个对象可以判断是哪一个 mutation 被调用了，额外的参数是什么。</span></div><div class="line">    store.subscribe(<span class="function">(<span class="params">mutation, state</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">if</span> (mutation.type === <span class="string">'updateA'</span>) &#123;</div><div class="line">            <span class="built_in">console</span>.log(mutation)</div><div class="line">            <span class="built_in">console</span>.log(state)</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> moduleA = &#123;</div><div class="line">    state: &#123;</div><div class="line">        a: <span class="number">1</span>,</div><div class="line">    &#125;,</div><div class="line">    mutations: &#123;</div><div class="line">        <span class="comment">// 被调用完成之后会触发 myPlugin 中的 subscribe 回调</span></div><div class="line">        updateA (context, payload) &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'A'</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    actions: &#123;...&#125;,</div><div class="line">    getters: &#123;...&#125;,</div><div class="line">    modules: &#123;...&#125;,</div><div class="line">    plugins: [myPlugin]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(moduleA);</div></pre></td></tr></table></figure>
<p><strong>注意：</strong>在插件中如果要修改state状态，也需要通过store调用commit，从而触发 mutation 改变state的状态，也就是说不能直接修改state状态。</p>
<h2 id="strict"><a href="#strict" class="headerlink" title="strict"></a>strict</h2><ul>
<li><p>上面一直强调就是修改只能在 mutations 中完成，为了强制约束，可是在vuex实例化的时候传入该属性（严格模式）。</p>
</li>
<li><p>语法</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> moduleA = &#123;</div><div class="line">    state: &#123;...&#125;,</div><div class="line">    mutations: &#123;...&#125;,</div><div class="line">    actions: &#123;...&#125;,</div><div class="line">    getters: &#123;...&#125;,</div><div class="line">    modules: &#123;...&#125;,</div><div class="line">    plugins: [...],</div><div class="line">    strict: <span class="literal">true</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(moduleA);</div></pre></td></tr></table></figure>

                
            
        
        </div>
        
    </article>
    

    
        
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年8月22日</span>
                
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                <a href="/2017/08/22/闭包/">闭包</a>
            
            </h1>
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                
                    <h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p><strong>闭包的目的</strong>：封装内部实现，构建私有作用域， <em>暴露公有的API</em> 。<br><strong>闭包的晦涩定义</strong>：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。<br><strong>闭包的简单定义</strong>：一个函数中定义了另一个函数。<br><strong>Example1</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </div><div class="line">	<span class="keyword">var</span> a=<span class="number">2</span>;</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; </div><div class="line">		<span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></div><div class="line">	&#125;</div><div class="line">	bar(); </div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure>
                    
            
        
            <p class="content-link">
                <a href="/2017/08/22/闭包/#more">
                    <span class="iconfont icon-right">继续阅读</span>
                </a>
            </p>
        
        </div>
        
    </article>
    

    
        
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年8月22日</span>
                
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                <a href="/2017/08/22/JS创建对象的最好用的两种方式/">JS创建对象的最好用的两种方式</a>
            
            </h1>
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                
                    <h2 id="组合使用构造函数模式和原型模式（最常用）"><a href="#组合使用构造函数模式和原型模式（最常用）" class="headerlink" title="组合使用构造函数模式和原型模式（最常用）"></a>组合使用构造函数模式和原型模式（最常用）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name</div><div class="line">  <span class="keyword">this</span>.friends = [‘Shelby’, ‘Court’]</div><div class="line">&#125;</div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person()</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person1.friends)  <span class="comment">//[“Shelby”, “Court”, “Van”]</span></div><div class="line"><span class="built_in">console</span>.log(person2.friends) <span class="comment">// [“Shelby”, “Court”]</span></div><div class="line"><span class="built_in">console</span>.log(person1.friends === person2.friends) <span class="comment">//false</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>优点：</strong>使用此模式可以让每个实例都会有自己的一份实例属性副本，但同时又共享着对方法的引用，这样的话，即使实例属性修改引用类型的值，也不会影响其他实例的属性值了</li>
</ul>
<h2 id="动态原型模式（红宝书认为最完美）"><a href="#动态原型模式（红宝书认为最完美）" class="headerlink" title="动态原型模式（红宝书认为最完美）"></a>动态原型模式（红宝书认为最完美）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, job</span>) </span>&#123;</div><div class="line">  <span class="comment">// 属性</span></div><div class="line">  <span class="keyword">this</span>.name = name</div><div class="line">  <span class="keyword">this</span>.job = job</div><div class="line">  </div><div class="line">  <span class="comment">// 方法</span></div><div class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName !== ‘<span class="function"><span class="keyword">function</span>’) </span>&#123;</div><div class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">    Person.prototype.writeName = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">       <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(‘Jiang’, ‘Student’)</div><div class="line">person1.sayName()</div></pre></td></tr></table></figure>
<ul>
<li><strong>优点：</strong>只有在sayName方法不存在的时候，才会将它添加到原型中。这段代码只会初次调用构造函数的时候才会执行。此后原型已经完成初始化，不需要在做什么修改了这里对原型所做的修改，能够立即在所有实例中得到反映。其次，if语句检查的可以是初始化之后应该存在的任何属性或方法，所以不必用一大堆的if语句检查每一个属性和方法，只要检查一个就行。</li>
</ul>

                
            
        
        </div>
        
    </article>
    

    
        
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年8月22日</span>
                
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                <a href="/2017/08/22/一段代码看出JS的的解析到执行的顺序规则/">一段代码看出JS的的解析到执行的顺序规则</a>
            
            </h1>
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                
                    <h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    b = <span class="number">3</span>;</div><div class="line">    <span class="keyword">var</span> b;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 打印出：10</span></div><div class="line">    <span class="built_in">console</span>.log(b); <span class="comment">// 打印出：3</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">bar(<span class="number">10</span>);</div></pre></td></tr></table></figure>
<p>##执行顺序</p>
<h3 id="函数外面的时候，代码拆成前后两部分来看："><a href="#函数外面的时候，代码拆成前后两部分来看：" class="headerlink" title="函数外面的时候，代码拆成前后两部分来看："></a>函数外面的时候，代码拆成前后两部分来看：</h3><h4 id="第-1-部分：（申明）"><a href="#第-1-部分：（申明）" class="headerlink" title="第 1 部分：（申明）"></a>第 1 部分：（申明）</h4><ul>
<li>1、申明了一个<code>bar=undefined</code>的函数变量，用代码可以看成：（<code>VO</code>是执行上下文，可以看成是<code>this</code><br>）</li>
</ul>
<blockquote>
<p>VO = {bar:undefined}</p>
</blockquote>
<h4 id="第-2-部分：（执行）"><a href="#第-2-部分：（执行）" class="headerlink" title="第 2 部分：（执行）"></a>第 2 部分：（执行）</h4><ul>
<li>2、执行<code>bar(10)</code>这里由于是函数，存在独立作用域，只要存在作用域就先解析，所以这里又可以拆成两部分来看：</li>
</ul>
<h5 id="第-2-1-部分：（申明）"><a href="#第-2-1-部分：（申明）" class="headerlink" title="第 2.1 部分：（申明）"></a>第 2.1 部分：（申明）</h5><ul>
<li>先声明<code>a=10</code>,<code>b=undefined</code>两个形参变量，再申明函数变量<code>b=function b(){}</code>，由于上下文<code>VO1</code>中已经存在 <code>b</code> 了，所以会覆盖掉形参<code>b</code>的申明，然后再申明<code>var</code>变量<code>b=undefined</code>，并覆盖已经存在<code>VO1</code>中函数变量<code>b</code>，用代码表示：</li>
</ul>
<blockquote>
<p>VO1 = {a：10,b:undefined}</p>
</blockquote>
<p><strong>注意：</strong>这里需要注意的是<strong>函数表达式</strong><code>return function a(){}</code>并不会提前申明，<code>函数表达式</code>和<code>函数申明</code>的异同是，除了标准的<code>函数申明</code>：<code>function a(){}</code>，其他的都是<code>函数表达式</code>，如：<code>var a = function (){}</code>、<code>(function a(){})</code>…等。<br><strong>注意：</strong>申明的权重：<strong>argument(函数的形参申明) &gt; function声明 &gt; var声明 (也就之前提高的变量提升Hoisting)</strong></p>
<h5 id="第-2-2-部分：（执行）"><a href="#第-2-2-部分：（执行）" class="headerlink" title="第 2.2 部分：（执行）"></a>第 2.2 部分：（执行）</h5><ul>
<li>先执行<code>b=3</code>，再执行两个console.log，再执行：函数表达式申明，及执行。</li>
</ul>

                
            
        
        </div>
        
    </article>
    

    
        
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年8月22日</span>
                
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                <a href="/2017/08/22/JS模块规范：AMD、UMD、CMD、commonJS、ES6 module/">JS模块规范：AMD、UMD、CMD、commonJS、ES6 module</a>
            
            </h1>
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                
                    <p>[TOC]</p>
<h2 id="commonJS"><a href="#commonJS" class="headerlink" title="commonJS"></a>commonJS</h2><ul>
<li>特点：</li>
</ul>
<blockquote>
<p>1、模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。<br>2、模块加载会阻塞接下来代码的执行，需要等到模块加载完成才能继续执行——同步加载。</p>
</blockquote>
<ul>
<li>环境：服务器环境</li>
<li>应用：nodejs的模块规范是参照commonJS实现的。</li>
<li>语法：</li>
</ul>
<blockquote>
<p>1、导入：require(‘路径’)<br>2、导出：module.exports和exports</p>
</blockquote>
<ul>
<li><p>注意：module.exports和exports的的区别是exports只是对module.exports的一个引用，相当于Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行<code>var exports = module.exports;</code>这样的命令。</p>
</li>
<li><p>demo</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.js</span></div><div class="line"><span class="comment">// 相当于这里还有一行：var exports = module.exports;代码</span></div><div class="line">exports.a = <span class="string">'Hello world'</span>;  <span class="comment">// 相当于：module.exports.a = 'Hello world';</span></div><div class="line"></div><div class="line"><span class="comment">// b.js</span></div><div class="line"><span class="keyword">var</span> moduleA = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</div><div class="line"><span class="built_in">console</span>.log(moduleA.a);     <span class="comment">// 打印出hello world</span></div></pre></td></tr></table></figure>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><ul>
<li>特点：</li>
</ul>
<blockquote>
<p>1、异步加载<br>2、管理模块之间的依赖性，便于代码的编写和维护。</p>
</blockquote>
<ul>
<li>环境：浏览器环境</li>
<li>应用：requireJS是参照AMD规范实现的</li>
<li>语法：</li>
</ul>
<blockquote>
<p>1、导入：require([‘模块名称’], function (‘模块变量引用’){// 代码});<br>3、导出：define(function (){return ‘值’);</p>
</blockquote>
<ul>
<li>demo</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.js</span></div><div class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">　　<span class="keyword">return</span> &#123;</div><div class="line">　　　a:<span class="string">'hello world'</span></div><div class="line">　　&#125;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// b.js</span></div><div class="line"><span class="built_in">require</span>([<span class="string">'./a.js'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">moduleA</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(moduleA.a); <span class="comment">// 打印出：hello world</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><ul>
<li>特点</li>
</ul>
<blockquote>
<p>1、CMD是在AMD基础上改进的一种规范，和AMD不同在于对依赖模块的执行时机处理不同，CMD是就近依赖，而AMD是前置依赖。</p>
</blockquote>
<ul>
<li>环境：浏览器环境</li>
<li>应用：seajs是参照UMD规范实现的，requireJS的最新的几个版本也是部分参照了UMD规范的实现</li>
<li>语法：</li>
</ul>
<blockquote>
<p>1、导入：define(function(require, exports, module) {});<br>2、导出：define(function (){return ‘值’);</p>
</blockquote>
<ul>
<li>demo</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.js</span></div><div class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>)</span>&#123;</div><div class="line">　　exports.a = <span class="string">'hello world'</span>;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// b.js</span></div><div class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> moduleA = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</div><div class="line">    <span class="built_in">console</span>.log(moduleA.a); <span class="comment">// 打印出：hello world</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h2><ul>
<li>特点：</li>
</ul>
<blockquote>
<p>1、兼容AMD和commonJS规范的同时，还兼容全局引用的方式</p>
</blockquote>
<ul>
<li>环境：浏览器或服务器环境</li>
<li>应用：无</li>
<li>语法：</li>
</ul>
<blockquote>
<p>1、无导入导出规范，只有如下的一个常规写法：</p>
</blockquote>
<ul>
<li>常规写法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">(function (root, factory) &#123;</div><div class="line">    if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123;</div><div class="line">        //AMD</div><div class="line">        define([&apos;jquery&apos;], factory);</div><div class="line">    &#125; else if (typeof exports === &apos;object&apos;) &#123;</div><div class="line">        //Node, CommonJS之类的</div><div class="line">        module.exports = factory(require(&apos;jquery&apos;));</div><div class="line">    &#125; else &#123;</div><div class="line">        //浏览器全局变量(root 即 window)</div><div class="line">        root.returnExports = factory(root.jQuery);</div><div class="line">    &#125;</div><div class="line">&#125;(this, function ($) &#123;</div><div class="line">    //方法</div><div class="line">    function myFunc()&#123;&#125;;</div><div class="line">    //暴露公共方法</div><div class="line">    return myFunc;</div><div class="line">&#125;));</div></pre></td></tr></table></figure>
<h2 id="ES6-module"><a href="#ES6-module" class="headerlink" title="ES6 module"></a>ES6 module</h2><ul>
<li>特点：</li>
</ul>
<blockquote>
<p>1、按需加载（编译时加载）<br>2、import和export命令只能在模块的顶层，不能在代码块之中（如：if语句中）,import()语句可以在代码块中实现异步动态按需动态加载</p>
</blockquote>
<ul>
<li>环境：浏览器或服务器环境（以后可能支持）</li>
<li>应用：ES6的最新语法支持规范</li>
<li>语法：</li>
</ul>
<blockquote>
<p>1、导入：import {模块名A，模块名B…} from ‘模块路径’<br>2、导出：export和export default<br>3、import(‘模块路径’).then()方法</p>
</blockquote>
<ul>
<li>注意：export只支持对象形式导出，不支持值的导出，export default命令用于指定模块的默认输出，只支持值导出，但是只能指定一个，本质上它就是输出一个叫做default的变量或方法。</li>
<li>规范：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*错误的写法*/</span></div><div class="line"><span class="comment">// 写法一</span></div><div class="line"><span class="keyword">export</span> <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">// 写法二</span></div><div class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</div><div class="line"><span class="keyword">export</span> m;</div><div class="line"></div><div class="line"><span class="comment">// 写法三</span></div><div class="line"><span class="keyword">if</span> (x === <span class="number">2</span>) &#123;</div><div class="line">  <span class="keyword">import</span> MyModual <span class="keyword">from</span> <span class="string">'./myModual'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*正确的三种写法*/</span></div><div class="line"><span class="comment">// 写法一</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> m = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">// 写法二</span></div><div class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</div><div class="line"><span class="keyword">export</span> &#123;m&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 写法三</span></div><div class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</div><div class="line"><span class="keyword">export</span> &#123;n <span class="keyword">as</span> m&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 写法四</span></div><div class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> n;</div><div class="line"></div><div class="line"><span class="comment">// 写法五</span></div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">    <span class="keyword">import</span>(<span class="string">'./myModule.js'</span>)</div><div class="line">    .then(<span class="function">(<span class="params">&#123;export1, export2&#125;</span>) =&gt;</span> &#123;</div><div class="line">      <span class="comment">// ...·</span></div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 写法六</span></div><div class="line"><span class="built_in">Promise</span>.all([</div><div class="line">  <span class="keyword">import</span>(<span class="string">'./module1.js'</span>),</div><div class="line">  <span class="keyword">import</span>(<span class="string">'./module2.js'</span>),</div><div class="line">  <span class="keyword">import</span>(<span class="string">'./module3.js'</span>),</div><div class="line">])</div><div class="line">.then(<span class="function">(<span class="params">[module1, module2, module3]</span>) =&gt;</span> &#123;</div><div class="line">   ···</div><div class="line">&#125;);</div></pre></td></tr></table></figure>

                
            
        
        </div>
        
    </article>
    

    
        
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年8月22日</span>
                
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                <a href="/2017/08/22/JS继承比较中寻找最优的继承方式/">JS继承比较中寻找最优的继承方式</a>
            
            </h1>
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                
                    <ul>
<li>继承主要满足两方面的要求：<ul>
<li>1、复用父构造函数中的代码</li>
<li>2、复用父原型中的代码</li>
</ul>
</li>
</ul>
<h2 id="继承方式1"><a href="#继承方式1" class="headerlink" title="继承方式1"></a>继承方式1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">age</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line">Child.prototype = <span class="keyword">new</span> Parent(<span class="string">'小明'</span>);</div><div class="line">Child.prototype.constructor = Child;</div><div class="line">Child.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.age;</div><div class="line">&#125;</div><div class="line"><span class="keyword">new</span> Child(<span class="number">14</span>)</div></pre></td></tr></table></figure>
<ul>
<li>结论：这种构造方式虽然满足了继承要求，但是存在两个问题<ul>
<li>1、如果name和age参数分开创建，这其实对于使用继承没有明显的好处，如果能都在Child构造函数中创建就更好一点。</li>
<li>2、因为子类是通过子类的prototype来接受父类的构造函数和父类prototype的，这样如果子类创建多个实例，而且同时修改他们的prototype就有可能互相影响。</li>
</ul>
</li>
</ul>
<h2 id="继承方式2"><a href="#继承方式2" class="headerlink" title="继承方式2"></a>继承方式2</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    Parent.call(<span class="keyword">this</span>, name);</div><div class="line">&#125;</div><div class="line">Child.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</div><div class="line">&#125;;</div><div class="line">Child.prototype.__proto__ = Parent.prototype;</div></pre></td></tr></table></figure>
<ul>
<li>结论：两方面都考虑了，而且也实现了再子类中实例化参数，多个实例间也不会互相影响，可是仍然存在两个问题：<ul>
<li>修改<strong>proto</strong>的性能耗损比较严重</li>
<li>兼容性也比较差</li>
</ul>
</li>
</ul>
<h2 id="继承方式3"><a href="#继承方式3" class="headerlink" title="继承方式3"></a>继承方式3</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    Parent.call(<span class="keyword">this</span>, name);</div><div class="line">&#125;</div><div class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype);  <span class="comment">// 通过创建一个新的对象去继承</span></div><div class="line">Child.prototype.constructor = Child;                <span class="comment">// 上面改变了constructor指向，这里最好改回来</span></div><div class="line">Child.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>结论：两方面都考虑了，而且也实现了再子类中实例化参数，多个实例间也不会互相影响，但是仍然存在一个问题：<ul>
<li>Object.create兼容性一般</li>
</ul>
</li>
</ul>
<h2 id="继承方式4（最优继承）"><a href="#继承方式4（最优继承）" class="headerlink" title="继承方式4（最优继承）"></a>继承方式4（最优继承）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.create !== <span class="string">"function"</span>) &#123;</div><div class="line">    <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">proto, propertiesObject</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> proto !== <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> proto !== <span class="string">'function'</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Object prototype may only be an Object: '</span> + proto);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (proto === <span class="literal">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> propertiesObject != <span class="string">'undefined'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"This browser's implementation of Object.create is a shim and doesn't support a second argument."</span>);</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">        F.prototype = proto;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;)();</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    Parent.call(<span class="keyword">this</span>, name);</div><div class="line">&#125;</div><div class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype);</div><div class="line">Child.prototype.constructor = Child;</div><div class="line">Child.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>结论：两方面都考虑了，而且也实现了再子类中实例化参数，多个实例间也不会互相影响，使用polyfill也解决了兼容性问题，所以这个是最优的继承方式</li>
</ul>

                
            
        
        </div>
        
    </article>
    

    
        
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年8月22日</span>
                
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                <a href="/2017/08/22/JS隐式类型转换的十二条规则/">JS隐式类型转换的十二条规则</a>
            
            </h1>
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                
                    <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote>
<p>“The comparison x == y, where x and y are values, producestrue or false.”</p>
<p>相等运算符用于比较两个值，返回true或false。</p>
</blockquote>
<h2 id="算法细节"><a href="#算法细节" class="headerlink" title="算法细节"></a>算法细节</h2><blockquote>
<p>1）ReturnIfAbrupt(x).<br>2）ReturnIfAbrupt(y).<br>3）If Type(x) is the same as Type(y), thenReturn the result of performing Strict Equality Comparisonx === y.<br>4）If x is null and y is undefined, return true.<br>5）If x is undefined and y is null, return true.<br>6）If Type(x) is Number and Type(y) is String,return the result of the comparison x == ToNumber(y).<br>7）If Type(x) is String and Type(y) is Number,return the result of the comparison ToNumber(x) == y.<br>8）If Type(x) is Boolean, return the result of the comparisonToNumber(x) == y.<br>9）If Type(y) is Boolean, return the result of the comparison x == ToNumber(y).<br>10）If Type(x) is either String, Number, or Symbol and Type(y)is Object, thenreturn the result of the comparison x == ToPrimitive(y).<br>11）If Type(x) is Object and Type(y) is either String, Number, or Symbol, thenreturn the result of the comparison ToPrimitive(x) == y.<br>12）Return false.</p>
<p>1）如果x不是正常值（比如抛出一个错误），中断执行。<br>2）如果y不是正常值，中断执行。<br>3）如果Type(x)与Type(y)相同，执行严格相等运算x === y。<br>4）如果x是null，y是undefined，返回true。<br>5）如果x是undefined，y是null，返回true。<br>6）如果Type(x)是数值，Type(y)是字符串，返回x == ToNumber(y)的结果。<br>7）如果Type(x)是字符串，Type(y)是数值，返回ToNumber(x) == y的结果。<br>8）如果Type(x)是布尔值，返回ToNumber(x) == y的结果。<br>9）如果Type(y)是布尔值，返回x == ToNumber(y)的结果。<br>10）如果Type(x)是字符串或数值或Symbol值，Type(y)是对象，返回x == ToPrimitive(y)的结果。<br>11）如果Type(x)是对象，Type(y)是字符串或数值或Symbol值，返回ToPrimitive(x) == y的结果。<br>12）返回false</p>
</blockquote>
<ul>
<li>注意：<strong>ToPrimitive(y)</strong> 的判断返回规则是，如果 y 不等于 Date 类型的对象，那么先比较y.valueOf() 的值，如果是基本类型返回，不是的话再比较 y.toString() 的值。</li>
</ul>

                
            
        
        </div>
        
    </article>
    

    
</section>
    
    <nav class="pagination">
        <a class="extend prev" rel="prev" href="/">< 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">下一页 ></a>
    </nav>


        </main>
        <footer class="footer syuanpi fadeIn" id="footer">
    <hr>
    <div class="footer-wrapper">
        <div class="left">
            <div class="contact-icon">
    
    
    
    
    
    
    
    
        
            <a href="https://github.com/yejiaming" class="iconfont icon-github" title="github"></a>
        
        
        
        
        
        
        
    
</div>
        </div>
        <div class="right">
            <div class="copyright">
    <div class="info">
        <span>&copy;</span>
        <span>2017 ~ 2018</span>
        <span>❤</span>
        <span>arvin ye</span>
    </div>
    <div class="theme">
        <span>
            动力来源于
            <a href="http://hexo.io/" target="_blank">Hexo </a>
        </span>
        <span>
            主题
            <a href="https://github.com/ColMugX/hexo-theme-Nlvi"> Nlvi </a>
        </span>
    </div>
    
    <div class="visit_count">
        <i class="iconfont icon-visit"></i>
        <span id="busuanzi_value_site_uv"></span>
        <i class="iconfont icon-people"></i>
        <span id="busuanzi_value_site_pv"></span>
    </div>
    
</div>
        </div>
    </div>
</footer>
    </div>
    <script src="/script/nlvi.js"></script>
<script src="/script/search.js"></script>

    <script src="/lightbox/js/lightbox.min.js"></script>

<script>
$(document).ready(function(){
    document.body.addEventListener('touchstart', function () {});
    $('.progress').hide();
    $('.body').show();
    Nlvi.tagcloud();
    Nlvi.mobileHeader();
    Nlvi.back2top();
    Nlvi.smoothScroll();
    Nlvi.onView();
    Nlvi.showToc();
    Nlvi.showComments();
    Nlvi.showReward();

    !CONFIG.animate && Nlvi.offAnimate();
    CONFIG.lightbox && Nlvi.onPicBox();
})
</script>
    </div>
    
    <div class="backtop syuanpi dead toTop" id="backtop">
    <i class="iconfont icon-up"></i>
    <span style="text-align:center;font-family:Georgia;"><span style="font-family:Georgia;" id="scrollpercent">1</span>%</span>
</div>
    
    <div class="search" id="search">
        <div class="mask" id="mask"></div>
        <div class="search-wrapper syuanpi">
            <h1 id="search-header" class="syuanpi">搜索一下？</h1>
            <div class="input">
                <input type="text" id="local-search-input" results="0" name="">
            </div>
            <div id="local-search-result"></div>
        </div>
    </div>
    <script>
    var GREETING = {
        morning: "当我们探索时，就要发现到真理",
        noon: "人的天职在于勇于探索真理。",
        after: "一件事实是一条没有性别的真理",
        night: "真理有时可能变得黯淡，但它永远不会熄灭",
        midnight: "真理在人那里获得生命力，并且展现出来"
    }
    $(document).ready(function(){
        Nlvi.search();
    });
    </script>

</body>
</html>
