<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[ES6迭代器（interator）和for...of循环]]></title>
      <url>/2017/08/22/ES6%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88interator%EF%BC%89%E5%92%8Cfor-of%E5%BE%AA%E7%8E%AF/</url>
      <content type="html"><![CDATA[<h1 id="ES6迭代器（interator）和for…of…循环"><a href="#ES6迭代器（interator）和for…of…循环" class="headerlink" title="ES6迭代器（interator）和for…of…循环"></a>ES6迭代器（interator）和for…of…循环</h1><p>或许在写ES6的代码的时候，你可能没有感觉有用过迭代器这个东西，可是ES6中的for…of…循环我们都不陌生，而for…of…循环的必要条件就是必须满足被循环的对象实现了迭代器接口才行。例子如下：</p>
<p><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> b = &#123;</div><div class="line">		name:<span class="string">'arvin'</span>,</div><div class="line">		age:<span class="number">30</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> a)&#123;</div><div class="line">		<span class="built_in">console</span>.log(i);     <span class="comment">// 结果依次是：1，2，3</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j <span class="keyword">of</span> b)&#123;</div><div class="line">		<span class="built_in">console</span>.log(j);     <span class="comment">// TypeError: b[Symbol.iterator] is not a function</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>代码解读：</strong>对于上面代码的结果我们基本都知道，可是为什么是这个结果就不会很懂了。从代码的结果可以看出，for…of…循环可行的条件是需要被循环对象实现一个以Symbol.iterator为方法属性才行。而数组对象是默认实现了该方法的，所以并未报错。现在我们就来具体实现一下这个迭代器接口。</p>
<p><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> b = &#123;</div><div class="line">		name:<span class="string">'arvin'</span>,</div><div class="line">		age:<span class="number">30</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">Object</span>.defineProperty(b, <span class="built_in">Symbol</span>.iterator, &#123;</div><div class="line">		enumerable: <span class="literal">false</span>,</div><div class="line">		writable: <span class="literal">false</span>,</div><div class="line">		configurable: <span class="literal">true</span>,</div><div class="line">		value: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">				<span class="keyword">var</span> me = <span class="keyword">this</span>;</div><div class="line">				<span class="keyword">var</span> idx = <span class="number">0</span>;</div><div class="line">				<span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(me);</div><div class="line">				<span class="keyword">return</span> &#123;</div><div class="line">						next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">								<span class="keyword">return</span> &#123;</div><div class="line">										value: me[keys[idx++]],</div><div class="line">										done: (idx &gt; keys.length)</div><div class="line">								&#125;</div><div class="line">						&#125;</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j <span class="keyword">of</span> b)&#123;</div><div class="line">		<span class="built_in">console</span>.log(j);     <span class="comment">// 结果依次是：arvin,30</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 下面的代码类似上面的for...of...循环的内部实现</span></div><div class="line"><span class="keyword">var</span> c = b[<span class="built_in">Symbol</span>.iterator]();</div><div class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">	<span class="keyword">var</span> newValue = c.next();</div><div class="line">	<span class="keyword">if</span>(newValue.done)&#123;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">console</span>.log(newValue.value)   <span class="comment">// 结果依次是：arvin,30</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>代码解读：</strong>从上面的这个demo可以看出，ES6的迭代器是<strong>实现要求必须要实现一个Symbol.iterator接口，并且该接口要返回一个带有next方法的对象，而且该next方法必须包含至少两个值，value以及done，前者是迭代器的输出值，后者是判断迭代终止条件。</strong>下面附上一个通用上传迭代器的运用例子：</p>
<p><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> getUploadObj = &#123;</div><div class="line">		getActiveUploadObj ()&#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">						<span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="string">'TXFTNActiveX.FTNUpload'</span>);   <span class="comment">// IE上传控件</span></div><div class="line">				&#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">						<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">				&#125;</div><div class="line">		&#125;,</div><div class="line">		getFalshUploadObj () &#123;  </div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">						<span class="keyword">new</span> ActiveXObject(<span class="string">'ShockwaveFlash.ShockwaveFlash'</span>);   <span class="comment">// Flash上传控件</span></div><div class="line">						<span class="keyword">let</span> str = <span class="string">'&lt;object type="application/x-shockwave-flash"&gt;&lt;/object&gt;'</span>;</div><div class="line">						<span class="keyword">return</span> $(str).appendTo($(<span class="string">'body'</span>));</div><div class="line">				&#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">						<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">				&#125;</div><div class="line">		&#125;,</div><div class="line">		getFormUploadObj () &#123;</div><div class="line">				<span class="keyword">let</span> str = <span class="string">'&lt;input name="file" type="file" calss="ui-file"/&gt;'</span>;   <span class="comment">// 表单上传</span></div><div class="line">				<span class="keyword">return</span> $(str).appendTo($(<span class="string">'body'</span>));</div><div class="line">		&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 给对象getUploadObj定义iterator接口，上面演示过这段代码</span></div><div class="line"><span class="comment">// 这里可以通过工厂模式，抽象成一个专门给对象安装iterator接口的函数，这样就可以省却很多重复代码了。</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(getUploadObj, <span class="built_in">Symbol</span>.iterator, &#123;</div><div class="line">		enumerable: <span class="literal">false</span>,</div><div class="line">		writable: <span class="literal">false</span>,</div><div class="line">		configurable: <span class="literal">true</span>,</div><div class="line">		value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">				<span class="keyword">var</span> o = <span class="keyword">this</span>;</div><div class="line">				<span class="keyword">var</span> idx = <span class="number">0</span>;</div><div class="line">				<span class="keyword">var</span> ks = <span class="built_in">Object</span>.keys(o);</div><div class="line">				<span class="keyword">return</span> &#123;</div><div class="line">						next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">								<span class="keyword">return</span> &#123;</div><div class="line">										value: o[ks[idx++]],</div><div class="line">										done: (idx &gt; ks.length)</div><div class="line">								&#125;</div><div class="line">						&#125;</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">iteratorUploadObj</span> (<span class="params">uploadObj</span>)</span>&#123;</div><div class="line">		<span class="comment">// 直接使用`for...of`遍历uploadObj对象</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">let</span> getUpload <span class="keyword">of</span> uploadObj)&#123;</div><div class="line">				<span class="keyword">let</span> uploadObj = getUpload();</div><div class="line">				<span class="keyword">if</span>(uploadObj) <span class="keyword">return</span> uploadObj;</div><div class="line">		&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> uploadObj = iteratorUploadObj(getUploadObj);</div><div class="line"><span class="built_in">console</span>.log(uploadObj);  <span class="comment">// [input, prevObject: Z.fn.init[1], context: undefined]</span></div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> interator </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从ES6生成器(Generator)原理解读，到理解ES7的asyn...await]]></title>
      <url>/2017/08/22/%E4%BB%8EES6%E7%94%9F%E6%88%90%E5%99%A8-Generator-%E5%8E%9F%E7%90%86%E8%A7%A3%E8%AF%BB%EF%BC%8C%E5%88%B0%E7%90%86%E8%A7%A3ES7%E7%9A%84asyn-await/</url>
      <content type="html"><![CDATA[<h1 id="从ES6生成器-Generator-原理解读，到理解ES7的asyn…await…"><a href="#从ES6生成器-Generator-原理解读，到理解ES7的asyn…await…" class="headerlink" title="从ES6生成器(Generator)原理解读，到理解ES7的asyn…await…"></a>从ES6生成器(Generator)原理解读，到理解ES7的asyn…await…</h1><p>##ES6生成器原理解读<br>生成器从本质上来说，是一种特殊的<a href="https://segmentfault.com/a/1190000010637886" target="_blank" rel="external">迭代器</a>。为什么这么说呢，下面来看一段代码：</p>
<p><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">arg</span>)</span>&#123;</div><div class="line">		<span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">		<span class="keyword">yield</span> arg;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> genHandle = gen(<span class="number">3</span>);</div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> genHandle)&#123;</div><div class="line">	<span class="built_in">console</span>.log(i);   <span class="comment">// 依次打印：2，3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> genHandle2 = gen(<span class="number">4</span>);</div><div class="line"><span class="built_in">console</span>.log(genHandle2.next()); <span class="comment">// &#123; value: 2, done: false &#125;</span></div><div class="line"><span class="built_in">console</span>.log(genHandle2.next()); <span class="comment">// &#123; value: 4, done: false &#125;</span></div><div class="line"><span class="built_in">console</span>.log(genHandle2.next()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>代码解读：</strong>从上面代码可以看出生成器其实是一个<strong>变异的函数</strong>，和一般的函数<strong>没什么不同</strong>，只是多了一个 <strong>*</strong> 来区分这是一个生成器。当然生成器内部多了一个<strong>yeild语句</strong>，作用显而易见是<strong>为了停止继续执行下面的代码，相当于return的作用一样，但是不同的是它可以保存进度，可以通过代码控制继续执行。而且这里的yeild一定要在生成器的作用域范围内才会有效</strong>，这点要注意。在执行完生成器返回的对象genHandle和genHandle2可以看出，它们都是<strong>迭代器</strong>，也就是说生成器执行结果返回的是<a href="https://segmentfault.com/a/1190000010637886" target="_blank" rel="external">迭代器</a>对象，即<strong>生成器可以看成是一个迭代器的构造器，可以用来构建生成迭代器。yield在生成器构建迭代器的过成中的作用中就类似于切割代码的作用，把代码切割成一个可以迭代的集合</strong>。下面是上面的gen生成器转成ES5的代码，如下：</p>
<p><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> regeneratorRuntime.wrap(<span class="function"><span class="keyword">function</span> <span class="title">gen$</span>(<span class="params">_context</span>) </span>&#123;</div><div class="line">				<span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">						<span class="keyword">switch</span> (_context.prev = _context.next) &#123;</div><div class="line">								<span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">										_context.next = <span class="number">2</span>;</div><div class="line">										<span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">								<span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">										_context.next = <span class="number">4</span>;</div><div class="line">										<span class="keyword">return</span> arg;</div><div class="line">								<span class="keyword">case</span> <span class="number">4</span>:</div><div class="line">								<span class="keyword">case</span> <span class="string">"end"</span>:</div><div class="line">										<span class="keyword">return</span> _context.stop();</div><div class="line">						&#125;</div><div class="line">				&#125;</div><div class="line">		&#125;, _marked[<span class="number">0</span>], <span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Example：</strong>为了便于理解，下面是我实现的一个简单的regeneratorRuntime.wrap函数来生成迭代器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> context = &#123;</div><div class="line">		next:<span class="number">0</span>,</div><div class="line">		prev:<span class="literal">null</span>,</div><div class="line">		gen$:<span class="literal">null</span>,</div><div class="line">		done:<span class="literal">false</span>,</div><div class="line">		stop:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">this</span>.done = <span class="literal">true</span>;</div><div class="line">		&#125;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(context, <span class="built_in">Symbol</span>.iterator, &#123;</div><div class="line">		enumerable: <span class="literal">false</span>,</div><div class="line">		writable: <span class="literal">false</span>,</div><div class="line">		configurable: <span class="literal">true</span>,</div><div class="line">		value: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">				<span class="keyword">var</span> me = <span class="keyword">this</span>;</div><div class="line">				<span class="keyword">return</span> &#123;</div><div class="line">						next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">							 <span class="keyword">var</span> nextValue = me.gen$(me);</div><div class="line">								<span class="keyword">return</span> &#123;</div><div class="line">										value: nextValue,</div><div class="line">										done: me.done</div><div class="line">								&#125;</div><div class="line">						&#125;</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">&#125;);</div><div class="line"><span class="keyword">var</span> regeneratorRuntime = &#123;</div><div class="line">	wrap:<span class="function"><span class="keyword">function</span>(<span class="params">_gen</span>)</span>&#123;</div><div class="line">		context.gen$ = _gen;</div><div class="line">		<span class="keyword">return</span> context;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> regeneratorRuntime.wrap(<span class="function"><span class="keyword">function</span> <span class="title">gen$</span>(<span class="params">_context</span>) </span>&#123;</div><div class="line">				<span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">					<span class="keyword">switch</span> (_context.prev = _context.next) &#123;</div><div class="line">						<span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">							_context.next = <span class="number">2</span>;</div><div class="line">							<span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">						<span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">							_context.next = <span class="number">4</span>;</div><div class="line">							<span class="keyword">return</span> arg;</div><div class="line">						<span class="keyword">case</span> <span class="number">4</span>:</div><div class="line">						<span class="keyword">case</span> <span class="string">"end"</span>:</div><div class="line">							<span class="keyword">return</span> _context.stop();</div><div class="line">					&#125;</div><div class="line">			&#125;</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> b = gen(<span class="number">3</span>);</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> c <span class="keyword">of</span> b)&#123;</div><div class="line">	<span class="built_in">console</span>.log(c);   <span class="comment">// 结果为：2，3</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>##理解ES7的 asyn…await…<br><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 正常异步执行</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">		resolve(<span class="number">3</span>)</div><div class="line">	&#125;).then(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(value)</div><div class="line">	&#125;)</div><div class="line">	<span class="built_in">console</span>.log(<span class="number">4</span>)</div><div class="line">&#125;</div><div class="line">demo();         <span class="comment">// 执行结果依次是：4，3</span></div><div class="line"></div><div class="line"><span class="comment">// 生成器异步转同步</span></div><div class="line"><span class="keyword">let</span> gen = <span class="literal">null</span>;</div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">genDemo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">yield</span> setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="number">3</span>);</div><div class="line">		gen.next();</div><div class="line">	&#125;,<span class="number">100</span>)</div><div class="line">	<span class="built_in">console</span>.log(<span class="number">4</span>)</div><div class="line">&#125;</div><div class="line">gen = genDemo();</div><div class="line">gen.next()  <span class="comment">// // 执行结果依次是：3，4</span></div><div class="line"></div><div class="line"><span class="comment">// async...await...异步转同步</span></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncDemo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">		resolve(<span class="number">3</span>)</div><div class="line">	&#125;).then(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(value)</div><div class="line">	&#125;)</div><div class="line">	<span class="built_in">console</span>.log(<span class="number">4</span>)</div><div class="line">&#125;</div><div class="line">asyncDemo();    <span class="comment">// 执行结果依次是：3，4</span></div></pre></td></tr></table></figure>
<p><strong>代码解读：</strong>从上述的例子可以看出，<strong>生成器是可以解决异步如果转成同步代码的问题，而async…await…的实现原理其实也是基于生成器来实现的，不过这里要注意的是async…await…必须要配合Promise来实现，因为Promise的决议回调函数里面集成了类似于生成器gen.next()这样的代码来控制继续执行代码</strong>。</p>
]]></content>
      
        
        <tags>
            
            <tag> Generator </tag>
            
            <tag> asyn...await </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[通过回调来理解Promise]]></title>
      <url>/2017/08/22/%E9%80%9A%E8%BF%87%E5%9B%9E%E8%B0%83%E6%9D%A5%E7%90%86%E8%A7%A3Promise/</url>
      <content type="html"><![CDATA[<p>#通过回调来理解Promise<br>我们都知道Promise的出现是为了规避回调地狱的，由此，我们先来深入了解一下回调的缺陷：</p>
<p>##回调</p>
<blockquote>
<p>1、缺乏信任</p>
<p>2、不确定性</p>
</blockquote>
<p><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> money = <span class="number">30</span>;</div><div class="line">order(money,<span class="function"><span class="keyword">function</span> <span class="title">getOrder</span>(<span class="params">orderId</span>)</span>&#123;  <span class="comment">// order是一个第三方的下订单的回调函数</span></div><div class="line">	 orderId &amp;&amp; pay(orderId);  <span class="comment">// 获取订单编号之后调用第三方支付pay方法去付款 </span></div><div class="line">&#125;)</div><div class="line"><span class="comment">// ...同步代码</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>代码解读：</strong>上面的代码只是常规代码中的一部分，其中order是一个第三方下订单的方法，需要携带回调函数过去获取订单编号，这里面就存在一些信任性和不确定性的问题，如：</p>
<blockquote>
<p>1、有可能回调函数getOrder始终不会被调用，那我们就永远拿不到订单编号去支付；<br>2、有可能回调了，可是回调了不止一次，导致我们重复去支付了；<br>3、不确定回掉时间，有可能立马回调，那么接下来的同步代码就会在回调之后执行，有可能它内部调用了异步代码再回调，那么接下来的同步代码就会在回调之前执行。<br>4、也有可能下订单的第三方模块自己内部出错了，导致我们没办法捕获异常；</p>
</blockquote>
<p>上面只是回调的一部分缺陷，但其实当我们不喜欢一个东西的时候总有这么多理由，当我们喜欢一个东西的时候，没有理由也会找一堆理由的，下面就是Promise的理由。</p>
<p>##Promise</p>
<blockquote>
<p>1、可信任性</p>
<p>2、确定性</p>
</blockquote>
<p>在解决上述的回调函数的问题之前，有必要先来认识一下Promise的一些主要方法：</p>
<p>####1、Promise的起点new Promise()</p>
<p><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">PromiseBack</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">		resolve();</div><div class="line">		resolve();</div><div class="line">		reject();</div><div class="line">		reject();</div><div class="line">		<span class="built_in">console</span>.log(<span class="number">2</span>);</div><div class="line">&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="number">4</span>);</div><div class="line">&#125;,()=&gt;&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="number">5</span>);</div><div class="line">&#125;)</div><div class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</div><div class="line"><span class="comment">// 执行结果依次是：1，2，3，4</span></div></pre></td></tr></table></figure>
<p><strong>代码解读：</strong>以上代码体现了new Promise的如下特性：</p>
<blockquote>
<p>1、一旦决议（调用过一次resolve或者reject）就不再重复调用决议回调或者改变决议回调。</p>
<p>2、决议代码是同步的，可是决议的成功或失败的回调代码一定是异步的，而且Promise的异步实现比setTimeout的调用时间更早，因为回调决议存在于Event loop的microtask队列中。</p>
</blockquote>
<p>###2、多Promise同时执行：Promise.all([ .. ])</p>
<p><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">		resolve(<span class="number">1</span>);</div><div class="line">&#125;);</div><div class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">		resolve(<span class="number">2</span>);</div><div class="line">		<span class="comment">// reject(3);</span></div><div class="line">&#125;);</div><div class="line"><span class="keyword">let</span> promise3 = <span class="built_in">Promise</span>.all([promise1,promise2]).then(<span class="function"><span class="keyword">function</span> <span class="title">resolveBack</span>(<span class="params">result</span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(result);    <span class="comment">// 打印结果是：[ 1, 2 ]</span></div><div class="line">&#125;,<span class="function"><span class="keyword">function</span> <span class="title">rejectBack</span>(<span class="params">result</span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(result);    <span class="comment">// 当promise2注释部分放开，非注释部分注释，打印结果是：3</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>代码解读：</strong>Promise.all方法对于promise数组的决议是：<strong>当其中所有的promise都是成功决议的时候，就会调用成功的决议回调resolveBack，并且把promise数组的决议值以数组的形式按照顺序返回resolve中的值；如果其中哪怕有一个失败的决议都会调用失败的决议回调rejectBack，并且只返回promise宿主中失败的决议值，以数组顺序返回</strong>。</p>
<p>###3、多Promise竞赛执行：Promise.race([ .. ])<br><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		resolve(<span class="number">1</span>);</div><div class="line">	&#125;,<span class="number">100</span>);</div><div class="line">&#125;);</div><div class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	 <span class="comment">//resolve(2);</span></div><div class="line">		reject(<span class="number">3</span>);</div><div class="line">	&#125;,<span class="number">50</span>);</div><div class="line">&#125;);</div><div class="line"><span class="keyword">let</span> promise3 = <span class="built_in">Promise</span>.race([promise1,promise2]).then(<span class="function"><span class="keyword">function</span> <span class="title">resolveBack</span>(<span class="params">result</span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(result);    <span class="comment">// 打印结果是：2</span></div><div class="line">&#125;,<span class="function"><span class="keyword">function</span> <span class="title">rejectBack</span>(<span class="params">result</span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(result);    <span class="comment">// 当promise2注释部分放开，非注释部分注释，打印结果是：3</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>代码解读：</strong>Promise.race方法和all方法不同，它对于promise数组的决议是：<strong>当promise数组中有一个成功了，那就会立即执行成功的决议回调，当有一个失败了，就会立即执行失败的决议回调，所以，它也叫*</strong>竞赛决议<em>，它的一个常用的应用场景就是<strong>异步请求超时处理</strong>，代码如下：<br>**</em>Example:<em>*</em></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// request(..)是一个支持Promise的Ajax工具</span></div><div class="line"><span class="keyword">let</span> promise1 = request( <span class="string">"http://some.url.1/"</span>);</div><div class="line"><span class="keyword">let</span> promise2 = <span class="function"><span class="keyword">function</span>(<span class="params">second=<span class="number">1000</span></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</div><div class="line">		setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">			reject(<span class="string">'请求超时'</span>);</div><div class="line">		&#125;,second)</div><div class="line">	&#125;)</div><div class="line">&#125;;</div><div class="line"><span class="keyword">let</span> promise3 = <span class="built_in">Promise</span>.race([promise1,promise2(<span class="number">3000</span>)])</div><div class="line">.then(<span class="function"><span class="keyword">function</span> <span class="title">resolveBack</span>(<span class="params">result</span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(result);</div><div class="line">&#125;,<span class="function"><span class="keyword">function</span> <span class="title">rejectBack</span>(<span class="params">result</span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(result);    <span class="comment">// 当请求超时3秒钟就决议失败，打印错误信息，如果这里信息是统一处理，那最好超时的值构造成和异步请求返回错误结果的值一致</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>###4、Promise错误处理catch…<br><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(a);</div><div class="line">&#125;).catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(err);     <span class="comment">// 打印结果：33 [ReferenceError: a is not defined]</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>代码解读：</strong>catch和then一样都是Promise的<strong>实例方法</strong>，而且也都调用完成之后也都会<strong>返回一个新的Promise实例</strong>，这样就可以继续then或catch了，这也就是<strong>Promise的“链式流”</strong>。其实catch本身实现和then是类似的，可以完全看成是then仅有失败决议回调，即：<strong>then(null,(err)=&gt;{})。也就是说then的失败决议当Promise决议代码出错了，哪怕没有调用reject方法，也是会被捕获到错误的</strong>。</p>
<p>###总结<br>浏览过上述方法之后，我们现在来解决一开始我们遇到的那个回调函数的问题，解决问题代码如下：</p>
<p><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> money = <span class="number">30</span>;</div><div class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">		order(money,<span class="function"><span class="keyword">function</span> <span class="title">getOrder</span>(<span class="params">orderId</span>)</span>&#123; </div><div class="line">				orderId ? resolve(orderId) : reject(orderId);</div><div class="line">		&#125;); </div><div class="line">&#125;);</div><div class="line"><span class="keyword">let</span> promise2 = <span class="function"><span class="keyword">function</span>(<span class="params">second=<span class="number">1000</span></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</div><div class="line">		setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">			reject(<span class="string">'请求超时'</span>);</div><div class="line">		&#125;,second)</div><div class="line">	&#125;)</div><div class="line">&#125;;</div><div class="line"><span class="keyword">let</span> promise3 = <span class="built_in">Promise</span>.race([promise1,promise2(<span class="number">3000</span>)])</div><div class="line">.then(<span class="function"><span class="keyword">function</span> <span class="title">resolveBack</span>(<span class="params">result</span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(result);</div><div class="line">&#125;,<span class="function"><span class="keyword">function</span> <span class="title">rejectBack</span>(<span class="params">result</span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(result);    <span class="comment">// 当请求超时，或者order内部代码错误等都会调用失败的决议</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">// ...同步代码</span></div></pre></td></tr></table></figure>
<p><strong>代码解读：</strong>上面这个Promise例子展示了对回调问题的规避，具体解决思路是：</p>
<blockquote>
<p>1、通过使用Promise.race竞赛决议方法解决如果第三方的order方法不调用getOrder的情况，可以定位到具体的错误代码和错误原因；<br>2、根据Promise的决议特性：一旦决议不可状态不可更改，不可重复。解决了回调了不止一次的问题；<br>3、根据Promise的决议回调是异步的特性，决议的回调一定是异步的特性，解决了回调时间的不确定性。<br>4、根据rejectBack类似catch的特性，失败的决议回调是可以捕获到决议代码异常的报错的，那这样，如果第三方内部出现了问题，是可以捕获到的。</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> Promise </tag>
            
            <tag> 回调 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从ES6的Proxy代理看ES5的代理如何实现]]></title>
      <url>/2017/08/22/%E4%BB%8EES6%E7%9A%84Proxy%E4%BB%A3%E7%90%86%E7%9C%8BES5%E7%9A%84%E4%BB%A3%E7%90%86%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h1 id="从ES6的Proxy代理看ES5的代理如何实现"><a href="#从ES6的Proxy代理看ES5的代理如何实现" class="headerlink" title="从ES6的Proxy代理看ES5的代理如何实现"></a>从ES6的Proxy代理看ES5的代理如何实现</h1><p>###ES6的Proxy代理</p>
<p><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;<span class="attr">name</span>:<span class="string">''</span>&#125;;</div><div class="line"><span class="keyword">var</span> personCopy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person,&#123;</div><div class="line">	get(target,key,receiver)&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'get方法被拦截。。。'</span>);</div><div class="line">		<span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target,key,receiver);</div><div class="line">	&#125;,</div><div class="line">	set(target,key,value,receiver)&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'set方法被拦截。。。'</span>)</div><div class="line">		<span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target,key,value,receiver);</div><div class="line">	&#125;</div><div class="line">&#125;)</div><div class="line">person.name = <span class="string">'arvin'</span>;  <span class="comment">// 未有拦截日志打出</span></div><div class="line">personCopy.name = <span class="string">'arvin'</span>;  <span class="comment">// set方法被拦截。。。</span></div><div class="line"><span class="built_in">console</span>.log(person.name);   <span class="comment">// 未有拦截日志打出</span></div><div class="line"><span class="built_in">console</span>.log(personCopy.name);   <span class="comment">// get方法被拦截。。。</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong><em>代码解读：</em></strong>从上述的例子可以看出，<strong>被代理对象person</strong>的get和set不会经过代理拦截器get，set，而只有<strong>代理对象personCopy</strong>在get和set方法调用的时候才会经过拦截器，由此可见ES6的代理Proxy并不是一个类似<strong>JAVA的AOP</strong>，而其实只是将person的<strong>引用</strong>赋值给了personCopy，让代理对象personCopy和被代理对象person指向了<strong>同一个内存空间</strong>，下面是我实现的一个用ES5写的Proxy拦截，供大家参考理解Proxy实现原理提供思路：</p>
<p><strong><em>Example：</em></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**浅拷贝工具方法**/</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">myObj</span>)</span>&#123;  </div><div class="line">		<span class="keyword">if</span>(<span class="keyword">typeof</span>(myObj) != <span class="string">'object'</span> || myObj == <span class="literal">null</span>) <span class="keyword">return</span> myObj;  </div><div class="line">		<span class="keyword">var</span> newObj = <span class="keyword">new</span> <span class="built_in">Object</span>();  </div><div class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> myObj)&#123;  </div><div class="line">			newObj[i] = clone(myObj[i]); </div><div class="line">		&#125;  </div><div class="line">		<span class="keyword">return</span> newObj;  </div><div class="line">&#125;</div><div class="line"><span class="comment">/*代理实现类*/</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProxyCopy</span>(<span class="params">target,handle</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> targetCopy = clone(target);</div><div class="line">	<span class="built_in">Object</span>.keys(targetCopy).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</div><div class="line">		<span class="built_in">Object</span>.defineProperty(targetCopy, key, &#123;</div><div class="line">			get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">				<span class="keyword">return</span> handle.get &amp;&amp; handle.get(target,key);</div><div class="line">			&#125;,</div><div class="line">			set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</div><div class="line">				handle.set &amp;&amp; handle.set();</div><div class="line">				target[key] = newVal;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;)</div><div class="line">	<span class="keyword">return</span> targetCopy;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = &#123;<span class="attr">name</span>:<span class="string">''</span>&#125;;</div><div class="line"><span class="keyword">var</span> personCopy = <span class="keyword">new</span> ProxyCopy(person,&#123;</div><div class="line">	get(target,key)&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'get方法被拦截。。。'</span>);</div><div class="line">		<span class="keyword">return</span> target[key];</div><div class="line">	&#125;,</div><div class="line">	set(target,key,value)&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'set方法被拦截。。。'</span>)</div><div class="line">		<span class="comment">// return true;</span></div><div class="line">	&#125;</div><div class="line">&#125;)</div><div class="line">person.name = <span class="string">'arvin'</span>;  <span class="comment">// 未有拦截日志打出</span></div><div class="line">personCopy.name = <span class="string">'arvin'</span>;  <span class="comment">// set方法被拦截。。。</span></div><div class="line"><span class="built_in">console</span>.log(person.name);   <span class="comment">// 未有拦截日志打出</span></div><div class="line"><span class="built_in">console</span>.log(personCopy.name);   <span class="comment">// get方法被拦截。。。</span></div></pre></td></tr></table></figure>
<p>###ES5对Proxy代理的实现</p>
<p>要说到ES5的代理实现，其中比较有名的就算是vue的双向绑定中到了get和set的代理拦截实现了，下面是一个仿照该技术的一个实现：</p>
<p><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 拦截器</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">		<span class="keyword">this</span>.data = data;</div><div class="line">		<span class="keyword">this</span>.walk(data);</div><div class="line">&#125;</div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">$Observer</span>)</span>&#123;</div><div class="line">		$Observer.prototype = &#123;</div><div class="line">				walk: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">						<span class="keyword">var</span> me = <span class="keyword">this</span>;</div><div class="line">						<span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">								me.convert(key, data[key]);</div><div class="line">						&#125;);</div><div class="line">				&#125;,</div><div class="line">				convert: <span class="function"><span class="keyword">function</span>(<span class="params">key, val</span>) </span>&#123;</div><div class="line">						<span class="keyword">this</span>.defineReactive(<span class="keyword">this</span>.data, key, val);</div><div class="line">				&#125;,</div><div class="line">				defineReactive: <span class="function"><span class="keyword">function</span>(<span class="params">data, key, val</span>) </span>&#123;</div><div class="line">						<span class="keyword">var</span> childObj = observe(val);</div><div class="line">						<span class="built_in">Object</span>.defineProperty(data, key, &#123;</div><div class="line">								enumerable: <span class="literal">true</span>, <span class="comment">// 可枚举</span></div><div class="line">								configurable: <span class="literal">false</span>, <span class="comment">// 不能再define</span></div><div class="line">								get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">										<span class="keyword">return</span> val;</div><div class="line">								&#125;,</div><div class="line">								set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</div><div class="line">										<span class="keyword">if</span> (newVal === val) &#123;</div><div class="line">												<span class="keyword">return</span>;</div><div class="line">										&#125;</div><div class="line">										val = newVal;</div><div class="line">										<span class="built_in">console</span>.log(<span class="string">"新的值是object的话，进行监听"</span>);</div><div class="line">										<span class="built_in">console</span>.log(<span class="string">"通知订阅者"</span>);</div><div class="line">										dep.notify();</div><div class="line">								&#125;</div><div class="line">						&#125;);</div><div class="line">				&#125;</div><div class="line">&#125;;</div><div class="line">&#125;)(Observer);</div><div class="line"><span class="comment">// 拦截器的出口</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">		<span class="keyword">if</span> (!value || <span class="keyword">typeof</span> value !== <span class="string">'object'</span>) &#123;</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Observer(value);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 代理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript中线程运行机制详解]]></title>
      <url>/2017/08/22/JavaScript%E4%B8%AD%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript中线程运行机制详解"><a href="#JavaScript中线程运行机制详解" class="headerlink" title="JavaScript中线程运行机制详解"></a>JavaScript中线程运行机制详解</h1><p>对于JavaScript我们都知道，他是个<strong>单线程语言</strong>，但是准确来说它是拥有一个<strong>执行程序主线程</strong>，和<strong>消息队列辅线程（Event Loop）</strong>，以及<strong>各个真正处理异步操作的工作线程</strong>。<br>当主线程执行JS程序的时候，如果遇到了<strong>异步的操作</strong>（如：click事件，setTimeOut,I/0操作,异步请求,Promise等）,主线程将各个异步任务交给<strong>工作线程</strong>，主线程继续执行，<strong>工作线程会判断是否到了要执行该异步操作</strong>的条件了，如果工作线程判断已经到了要执行工作线程的条件之后，就会把回调函数放入辅线程<strong>Event Loop</strong>的<strong>macrotask任务队列或者microtask任务队列的</strong>队尾。当上述主线程执行完后续同步调用的代码之后，辅线程会一直循环上面两个队列，首先执行的是microtask任务队列，而且该任务队列是该次循环就会执行完并清空的，macrotask会等到下次event loop循环的时候执行。<br><a id="more"></a><br><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span>  <span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line"><span class="number">2.</span>  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timerCallback</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="number">3.</span>    <span class="built_in">console</span>.log(<span class="number">2</span>);</div><div class="line"><span class="number">4.</span>  &#125;,<span class="number">0</span>)</div><div class="line"><span class="number">5.</span>  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line"><span class="number">6.</span>     <span class="built_in">console</span>.log(<span class="number">3</span>);</div><div class="line"><span class="number">7.</span>     <span class="keyword">if</span>(<span class="literal">true</span>)</div><div class="line"><span class="number">8.</span>         resolve();</div><div class="line"><span class="number">9.</span>  &#125;).then(<span class="function"><span class="keyword">function</span> <span class="title">resolveCallback</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="number">10.</span>     <span class="built_in">console</span>.log(<span class="number">4</span>);</div><div class="line"><span class="number">11.</span> &#125;);</div><div class="line"><span class="number">12.</span> <span class="built_in">console</span>.log(<span class="number">5</span>);</div><div class="line"><span class="comment">// 上面程序执行的顺序是：1，3，5，4，2</span></div></pre></td></tr></table></figure>
<p><strong><em>代码详解：</em></strong>当主线程执行上述代码的时候，从<strong>上往下执行</strong>：<br>1、先将console.log(1)这句代码做一个<strong>入栈执行</strong>的操作，打印出1，该句代码没有<strong>后续的方法调用</strong>了，就<strong>出栈销毁</strong>；</p>
<p>2、执行setTimeout，将改句代码入栈执行，判断到该方法属于<strong>WebAPIs</strong>（JS工作线程提供API的统称，其中包含了webcore工作模块提供了DOM Binding、network、timer等），timerCallback方法出栈，交给工作线程webcore下的timer模块，这里timer模块会判断是否到了执行条件了，由于是延时是0，所以timer模块判断可以执行了，并将回调函数timerCallback放到辅助线程<strong>Event Loop的macrotask队尾</strong>，等待<strong>下一次Event Loop循环</strong>去执行。</p>
<p>3、继续执行Promise这句代码（<strong>包括then语句</strong>），将其入栈执行，判断该Promise属于<strong>Promise模块</strong>（非WebAPIs）,将其then的回调函数交给Promise模块，有后续调用；将execute方法入栈执行，有后续调用；将console.log(3)入栈执行，打印出3，console.log(3)执行完毕，出栈销毁；有后续调用if(true)入栈执行，判断为true，出栈销毁，继续将resolve()入栈执行，判断<strong>resolve()是WebAPIs的成功的回调</strong>，执行的时候通知到上面的Promise模块，<strong>Promise模块将成功的回调放到Event Loop的microtask队尾</strong>，resolve()出栈销毁，无后续调用，Promise出栈销毁。</p>
<p>4、继续执行，将console.log(5)入栈执行,打印出5，无后续调用，出栈销毁。</p>
<p>5、<strong>Event Loop开始循环microtask队列</strong>，将resolveCallback()入栈执行，有后续调用；将console.log(4)入栈执行，打印出4，出栈销毁；无后续调用，resolveCallback()出栈销毁，清空队列。</p>
<p>6、<strong>Event Loop开始循环macrotask队列</strong>，将timerCallback()入栈执行，有后续调用；将console.log(2)入栈执行，打印出2，出栈销毁，无后续调用；将timerCallback()出栈销毁，清空队列。</p>
<p>###备注：<br>macrotask任务队列的来源有：</p>
<ul>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmediate</li>
<li>I/O</li>
<li>UI rendering</li>
</ul>
<p>microtask任务队列的来源有：</p>
<ul>
<li>process.nextTick</li>
<li>promises</li>
<li>Object.observe</li>
<li>MutationObserver</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES5的原型链和ES6的类实现详解]]></title>
      <url>/2017/08/22/ES5%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%92%8CES6%E7%9A%84%E7%B1%BB%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="ES5的原型链和ES6的类实现详解"><a href="#ES5的原型链和ES6的类实现详解" class="headerlink" title="ES5的原型链和ES6的类实现详解"></a>ES5的原型链和ES6的类实现详解</h1><p>JavaScript最初设计时受到了<strong>面相对象编程</strong>的影响，从而引入了<strong>new关键字</strong>，来<strong>实例化对象</strong>。而在ES5中new后面跟着的是<strong>构造函数</strong>（也是函数），而到了ES6则改成了<strong>clas</strong>了，而一开始new创建对象都是<strong>独立的对象</strong>，并不能像java那样拥有<strong>继承</strong>的概念，去<strong>共享变量和方法</strong>，为了解决这个问题，JavaScript就又给构造函数设计了一个<strong>prototype</strong>属性，这样所有<strong>私有的方法和变量</strong>就放到<strong>构造函数</strong>里面定义，而所有的<strong>公共的变量和方法</strong>就放到<strong>prototype对象</strong>里面，这样当构造函数创建一个实例化的对象的时候，就即拥有自己的私有变量和方法，也有公有的变量和方法了，实例化出来的对象的私有方法和变量修改都不会互相有影响，只有在修改公有的变量和方法的时候是对所有实例生效的。<br><a id="more"></a></p>
<p>###ES5原型链<br><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">$Person</span>)</span>&#123;</div><div class="line">	$Person.prototype = &#123;</div><div class="line">		welcome: <span class="string">"hello"</span>,</div><div class="line">		introduce: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.welcome + <span class="string">",I am "</span> + <span class="keyword">this</span>.name;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;)(Person)</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"arvin"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"peter"</span>);</div><div class="line"><span class="built_in">console</span>.log(person1.introduce());   <span class="comment">// hello,I am arvin</span></div><div class="line"><span class="built_in">console</span>.log(person2.introduce());   <span class="comment">// hello,I am peter</span></div><div class="line"></div><div class="line">person1.__proto__.welcome = <span class="string">"hi"</span>;</div><div class="line"><span class="built_in">console</span>.log(person1.introduce());   <span class="comment">// hi,I am arvin</span></div><div class="line"><span class="built_in">console</span>.log(person2.introduce());   <span class="comment">// hi,I am peter</span></div></pre></td></tr></table></figure>
<p><strong><em>代码解读：</em></strong>以上是本人推荐在使用ES5时，写原型链的方法，目的是为了代码简洁，方便复用，仅供参考。代码中在原型链上定义了一个welcome<strong>公共变量</strong>，这里要注意的是如果有同样名称的<strong>私有变量</strong>welcome时，原型方法introduce里面的this.welcome会<strong>首先查找私有变量welcome并使用</strong>，这个其实就和面相对象的<strong>覆写</strong>类似了。另外可以看出，ES5的构造函数（一般首字母大写以区分普通函数）在new的时候确实是<strong>创建了不同的区块</strong>来存放其<strong>私有变量</strong>name的值的，而对于原型链的变量welcome和方法introduce也确实是各个Person实例<strong>共用了同一块内存区域</strong>的，只要其中<strong>一个</strong>修改了原型链上的变量<strong>其他所有的对象实例</strong>再调用的时候从公共内存取出来的也就是被修改过只有的值了，这里要注意的是，构造函数new出来的实例对象，创建出来的指向原型链prototype的是其<strong>proto</strong>属性，也就是说<strong>person1.<strong>proto</strong> === Person.prototype === person2.<strong>proto</strong></strong>，这也从实际上证明了<strong>原型链对象在内存中只存了一份，是共用的</strong>。</p>
<p>###ES6类<br><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span>(name) &#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line">	welcome = <span class="string">'hello'</span>;  <span class="comment">// S7才支持实例属性</span></div><div class="line">	introduce()&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.welcome + <span class="string">",I am "</span> + <span class="keyword">this</span>.name;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"arvin"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"peter"</span>);</div><div class="line"><span class="built_in">console</span>.log(person1.introduce());   <span class="comment">// hello,I am arvin</span></div><div class="line"><span class="built_in">console</span>.log(person2.introduce());   <span class="comment">// hello,I am peter</span></div><div class="line"></div><div class="line">person1.__proto__.welcome = <span class="string">"hi"</span>;</div><div class="line"><span class="built_in">console</span>.log(person1.introduce());   <span class="comment">// hi,I am arvin</span></div><div class="line"><span class="built_in">console</span>.log(person2.introduce());   <span class="comment">// hi,I am peter</span></div></pre></td></tr></table></figure>
<p><strong><em>代码解读：</em></strong>上面暂时只是概念性的写法，事实上，ES6的类只是一个ES5原型链的语法糖而已，主要是从写法上更接近于面相对象的类而已，另外一个作用就是区分ES5的构造函数和函数之间的区分。</p>
<p>###小结：对于ES5和ES6的类似面相对象和非面向对象的原因，以java为例提出以下几点个人见解：</p>
<blockquote>
<p>1、java在继承（extend）的时候，子类是会复制一遍所有父类的方法和属性（除已覆写的除外）到一个独立的内存空间中的，即所有子类之间不存在任何的关系；而这点其实就和ES5的原型继承prototype和ES6的extend有很大的不同了。</p>
<p>2、java在new创建一个实例的时候同样是会开辟一个独立的属于该实例的内存空间，同一个类的实例之间互不影响；而ES5和ES6的创建实例的时候实例仍然是和类是存在关联的，而且是可以直接影响到类以及其他子类的公共状态和方法的。</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> 原型链 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常用正则表达式及其思路详解]]></title>
      <url>/2017/08/22/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%80%9D%E8%B7%AF%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="常用正则表达式及其思路详解"><a href="#常用正则表达式及其思路详解" class="headerlink" title="常用正则表达式及其思路详解"></a>常用正则表达式及其思路详解</h1><p><strong>注意：</strong>正则表达式的匹配<strong>超大文本</strong>的效率比较低，为了匹配效率加快，最好是是先精确到小模块，再使用正则匹配，这样搜索效率会快一点。</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> vaildReg = &#123;</div><div class="line">	<span class="comment">//判断是否为QQ号码</span></div><div class="line">	isQQ:<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</div><div class="line">		<span class="comment">//1.校验首字母是不是数字,并且大于0。^[1-9]</span></div><div class="line">		<span class="comment">//2.校验QQ总长度最大为11位，最小为5位</span></div><div class="line">		<span class="keyword">var</span> reg = <span class="regexp">/^[1-9][0-9]&#123;4,10&#125;$/g</span>;</div><div class="line">		<span class="keyword">if</span>(reg.test(str))&#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	<span class="comment">//判断是否为手机号码</span></div><div class="line">	isMobile:<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</div><div class="line">		<span class="comment">//1.手机号的第一个是1开头</span></div><div class="line">		<span class="comment">//2.手机号的第二位虽然一般都是3，4，5，7，8，但是为了防止以后再增长所以不校验第二位</span></div><div class="line">		<span class="comment">//3.手机号第三位以后的9位都是[0-9]之间的数字</span></div><div class="line">		<span class="comment">//4.总长度是11位</span></div><div class="line">		<span class="keyword">var</span> reg = <span class="regexp">/^1[0-9]&#123;10&#125;$/g</span>;</div><div class="line">		<span class="keyword">if</span>(reg.test(str))&#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	<span class="comment">//判断是否为合法的email邮箱</span></div><div class="line">	isMail:<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</div><div class="line">		<span class="comment">//1.中间有@符号</span></div><div class="line">		<span class="comment">//2.@符号前面有至少1位数字或字母</span></div><div class="line">		<span class="comment">//3.@符号后面以什么什么.加上字母结尾</span></div><div class="line">		<span class="comment">//4.@和.com之间有至少1位数字或字母</span></div><div class="line">		<span class="keyword">var</span> reg = <span class="regexp">/^[0-9a-zA-Z.-]&#123;1,&#125;@[0-9a-zA-Z.-]&#123;1,&#125;.[a-zA-Z]+$/g</span>;</div><div class="line">		<span class="keyword">if</span>(reg.test(str))&#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	<span class="comment">//判断是否为数字</span></div><div class="line">	isNumber:<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</div><div class="line">		<span class="comment">//1.开头一直到最后都是数字^\d+</span></div><div class="line">		<span class="keyword">var</span> reg = <span class="regexp">/^\d+$/g</span>;</div><div class="line">		<span class="keyword">if</span>(reg.test(str))&#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	<span class="comment">//判断是否全都为中文</span></div><div class="line">	isAllChinese:<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</div><div class="line">		<span class="comment">//1.正则判断中文根据unicode编码来判断，中文在unicode编码中是\u4e00到\u9fa5，共有20901个汉字</span></div><div class="line">		<span class="keyword">var</span> reg = <span class="regexp">/^[\u4e00-\u9fa5]+$/gm</span>;</div><div class="line">		<span class="keyword">if</span>(reg.test(str))&#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	<span class="comment">//判断是否包含中文</span></div><div class="line">	isContainChinese:<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</div><div class="line">		<span class="comment">//1.正则判断中文根据unicode编码来判断，中文在unicode编码中是\u4e00到\u9fa5，共有20901个汉字</span></div><div class="line">		<span class="keyword">var</span> reg = <span class="regexp">/[\u4e00-\u9fa5]/gm</span>;</div><div class="line">		<span class="keyword">if</span>(reg.test(str))&#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	<span class="comment">//判断是否为邮政编码</span></div><div class="line">	isPostcode:<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</div><div class="line">		<span class="comment">//1.首字母不为0，再有5个任意数字</span></div><div class="line">		<span class="keyword">var</span> reg = <span class="regexp">/^[^0][0-9]&#123;5&#125;$/g</span>;</div><div class="line">		<span class="keyword">if</span>(reg.test(str))&#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	<span class="comment">//判断是否为合法的身份证号码，校验15位和18位身份证</span></div><div class="line">	isIDcard:<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</div><div class="line">		<span class="comment">//1.15位的身份证号码是有18**|19**年出身的人</span></div><div class="line">		<span class="comment">//2.18位的身份证末尾多了一个随机校验码</span></div><div class="line">		<span class="comment">//3.身份证前6位是地址码，后8位是出身日期，再后3位是顺序码，最后一位是校验码。</span></div><div class="line">		<span class="comment">//4.地址码表示编码对象常住户口所在县(市、旗、区)的行政区划代码。</span></div><div class="line">		<span class="comment">//5.出生日期码表示编码对象出生的年、月、日，其中年份用四位数字表示，年、月、日之间不用分隔符。</span></div><div class="line">		<span class="comment">//6.顺序码表示同一地址码所标识的区域范围内，对同年、月、日出生的人员编定的顺序号。顺序码的奇数分给男性，偶数分给女性。</span></div><div class="line">		<span class="comment">//7.校验码是根据前面十七位数字码，按照ISO 7064:1983.MOD 11-2校验码计算出来的检验码。</span></div><div class="line">		<span class="keyword">var</span> reg = <span class="regexp">/^[1-9]\d&#123;5&#125;(18|19|20)?\d&#123;2&#125;(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])\d&#123;3&#125;(\d|X)?$/g</span>;</div><div class="line">		<span class="comment">//前两位地址码规律</span></div><div class="line">		<span class="keyword">var</span> city=&#123;<span class="number">11</span>:<span class="string">"北京"</span>,<span class="number">12</span>:<span class="string">"天津"</span>,<span class="number">13</span>:<span class="string">"河北"</span>,<span class="number">14</span>:<span class="string">"山西"</span>,<span class="number">15</span>:<span class="string">"内蒙古"</span>,<span class="number">21</span>:<span class="string">"辽宁"</span>,<span class="number">22</span>:<span class="string">"吉林"</span>,<span class="number">23</span>:<span class="string">"黑龙江 "</span>,<span class="number">31</span>:<span class="string">"上海"</span>,<span class="number">32</span>:<span class="string">"江苏"</span>,<span class="number">33</span>:<span class="string">"浙江"</span>,<span class="number">34</span>:<span class="string">"安徽"</span>,<span class="number">35</span>:<span class="string">"福建"</span>,<span class="number">36</span>:<span class="string">"江西"</span>,<span class="number">37</span>:<span class="string">"山东"</span>,<span class="number">41</span>:<span class="string">"河南"</span>,<span class="number">42</span>:<span class="string">"湖北 "</span>,<span class="number">43</span>:<span class="string">"湖南"</span>,<span class="number">44</span>:<span class="string">"广东"</span>,<span class="number">45</span>:<span class="string">"广西"</span>,<span class="number">46</span>:<span class="string">"海南"</span>,<span class="number">50</span>:<span class="string">"重庆"</span>,<span class="number">51</span>:<span class="string">"四川"</span>,<span class="number">52</span>:<span class="string">"贵州"</span>,<span class="number">53</span>:<span class="string">"云南"</span>,<span class="number">54</span>:<span class="string">"西藏 "</span>,<span class="number">61</span>:<span class="string">"陕西"</span>,<span class="number">62</span>:<span class="string">"甘肃"</span>,<span class="number">63</span>:<span class="string">"青海"</span>,<span class="number">64</span>:<span class="string">"宁夏"</span>,<span class="number">65</span>:<span class="string">"新疆"</span>,<span class="number">71</span>:<span class="string">"台湾"</span>,<span class="number">81</span>:<span class="string">"香港"</span>,<span class="number">82</span>:<span class="string">"澳门"</span>,<span class="number">91</span>:<span class="string">"国外 "</span>&#125;;</div><div class="line">		<span class="keyword">if</span>(reg.test(str))&#123;</div><div class="line">			<span class="keyword">if</span>(!city[str.substr(<span class="number">0</span>,<span class="number">2</span>)])&#123;</div><div class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">			&#125;<span class="keyword">else</span>&#123;</div><div class="line">				<span class="comment">//18位身份证需要验证最后一位校验位</span></div><div class="line">				<span class="keyword">if</span>(str.length == <span class="number">18</span>)&#123;</div><div class="line">						<span class="keyword">var</span> arrInt = [<span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>];</div><div class="line">						<span class="keyword">var</span> arrCh = [<span class="string">'1'</span>, <span class="string">'0'</span>, <span class="string">'X'</span>, <span class="string">'9'</span>, <span class="string">'8'</span>, <span class="string">'7'</span>, <span class="string">'6'</span>, <span class="string">'5'</span>, <span class="string">'4'</span>, <span class="string">'3'</span>, <span class="string">'2'</span>];</div><div class="line">						<span class="keyword">var</span> sum = <span class="number">0</span>, i, residue;</div><div class="line">						<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">17</span>; i++) &#123;</div><div class="line">							sum += str.substr(i, <span class="number">1</span>) * arrInt[i];</div><div class="line">						&#125;</div><div class="line">						residue = arrCh[sum % <span class="number">11</span>];</div><div class="line">						<span class="keyword">if</span> (residue !== str.substr(<span class="number">17</span>, <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	<span class="comment">//判断是否为合法http地址</span></div><div class="line">	isURL:<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</div><div class="line">		<span class="comment">//1.合法URL地址，协议一定不能少,是不是https的就不所谓了</span></div><div class="line">		<span class="comment">//2.双斜杠之后，可能会存在域名地址，也可能是IP地址(可能就会带端口好了)</span></div><div class="line">		<span class="comment">//</span></div><div class="line">		<span class="keyword">var</span> reg = <span class="regexp">/^https?:\/\/[a-zA-Z0-9._-]+(:\d+)?(\/((\.)?(\?)?=?&amp;?[a-zA-Z0-9_-](\?)?)*)*$/i</span>;</div><div class="line">		<span class="keyword">if</span>(reg.test(str))&#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	<span class="comment">//判断是否为合法的IP4地址</span></div><div class="line">	isIP4:<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</div><div class="line">		<span class="comment">// 1、1.1.1.1  四段  [0 , 255]</span></div><div class="line">		<span class="comment">// 2.第一段不能为0</span></div><div class="line">		<span class="comment">// 3.每个段不能以0开头</span></div><div class="line">		<span class="keyword">var</span> reg = <span class="regexp">/^([1-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))&#123;3&#125;$/gi</span>;</div><div class="line">		<span class="keyword">if</span>(reg.test(str))&#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	<span class="comment">//去掉前后所有的空格，换行等</span></div><div class="line">	trim:<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</div><div class="line">		<span class="comment">//1.开头空格，匹配多次^(\s|\n|\r)+</span></div><div class="line">		<span class="comment">//2.末尾空格，匹配多次(\s|\n|\r)+$</span></div><div class="line">		str = str + <span class="string">''</span>;</div><div class="line">		<span class="keyword">var</span> reg = <span class="regexp">/^\s|\s+$/gim</span>;</div><div class="line">		<span class="keyword">return</span> str.replace(reg,<span class="string">''</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'QQ'</span>,vaildReg.isQQ(<span class="string">'12345678901'</span>)?<span class="string">'校验通过'</span>:<span class="string">'校验失败'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'手机'</span>,vaildReg.isMobile(<span class="string">'13700000000'</span>)?<span class="string">'校验通过'</span>:<span class="string">'校验失败'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'邮箱'</span>,vaildReg.isMail(<span class="string">'1333-.@3.a'</span>)?<span class="string">'校验通过'</span>:<span class="string">'校验失败'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'数字'</span>,vaildReg.isNumber(<span class="string">'0333'</span>)?<span class="string">'校验通过'</span>:<span class="string">'校验失败'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'全为中文'</span>,vaildReg.isAllChinese(<span class="string">'你三好'</span>)?<span class="string">'校验通过'</span>:<span class="string">'校验失败'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'包含中文'</span>,vaildReg.isContainChinese(<span class="string">'33AAA你AA'</span>)?<span class="string">'校验通过'</span>:<span class="string">'校验失败'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'邮政编码'</span>,vaildReg.isPostcode(<span class="string">'123456'</span>)?<span class="string">'校验通过'</span>:<span class="string">'校验失败'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'身份证号码'</span>,vaildReg.isIDcard(<span class="string">'362321199310207836'</span>)?<span class="string">'校验通过'</span>:<span class="string">'校验失败'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'URL地址'</span>,vaildReg.isURL(<span class="string">'http://33:33/JM2X/1'</span>)?<span class="string">'校验通过'</span>:<span class="string">'校验失败'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'IP地址'</span>,vaildReg.isIP4(<span class="string">'925.255.255.255'</span>)?<span class="string">'校验通过'</span>:<span class="string">'校验失败'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'去除空格:'</span>,vaildReg.trim(<span class="string">' \n\r\tAAA   03\r33  \r'</span>));</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES5和ES6数组遍历方法详解]]></title>
      <url>/2017/08/22/ES5%E5%92%8CES6%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="ES5和ES6数组遍历方法详解"><a href="#ES5和ES6数组遍历方法详解" class="headerlink" title="ES5和ES6数组遍历方法详解"></a>ES5和ES6数组遍历方法详解</h1><p>###在ES5中常用的10种数组遍历方法:</p>
<blockquote>
<p>1、原始的for循环语句<br>2、Array.prototype.forEach数组对象内置方法<br>3、Array.prototype.map数组对象内置方法<br>4、Array.prototype.filter数组对象内置方法<br>5、Array.prototype.reduce数组对象内置方法<br>6、Array.prototype.some数组对象内置方法<br>7、Array.prototype.every数组对象内置方法<br>8、Array.prototype.indexOf数组对象内置方法<br>9、Array.prototype.lastIndexOf数组对象内置方法<br>10、for…in循环语句<br><a id="more"></a></p>
<p>###ES6中新增加了一种：<br>1.for…of循环语句</p>
</blockquote>
<p>###ES5三种数组循环示例如下：</p>
<p>####原始for循环语句<br><strong>Example1</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</div><div class="line">		<span class="built_in">console</span>.log(a[i]);  <span class="comment">//结果依次为1，2，3</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码解读：</em></strong>原始for循环的优点在于大家都比较熟悉，容易理解，劣势是写起来比较繁琐，需要定义额外更多的变量，所以一下是针对于原始for循环的改良的两种写法：<br><strong><em>Example1</em></strong>：写法改良版</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=a.length;i--;)&#123;</div><div class="line">		<span class="built_in">console</span>.log(a[i]);  <span class="comment">//结果依次为3，2，1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>Example2</em></strong>：性能改良版</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>,len=a.length; i &lt; len; i++) &#123;</div><div class="line">	 <span class="built_in">console</span>.log(a[i]);  <span class="comment">//结果依次为1，2，3</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意</strong>:以上代码可以写成这样呢，如果懵逼了的话接着看原始for循环的解读,我们都知道for循环包含三个语句块——&gt;<strong>for(语句1；语句2；语句3）{被执行的代码}</strong>，其中，<strong>语句1</strong>一般为<strong>变量定义语句</strong>（不仅可以只定义一个变量哦），在<strong>循环开始前</strong>执行，而且<strong>只执行一次</strong>；<strong>语句2</strong>定义循环的是否继续执行的条件，同样也是在<strong>循环开始前</strong>执行，<strong>语句1</strong>之后执行，每次<strong>重新开始循环都会再次执行</strong>；<strong>语句3</strong>则在<strong>循环结束之后执行</strong>，并且<strong>每次结束的时候都会再次执行</strong>，这里要注意的是如果被执行的代码<strong>中途return</strong>出来了那是不会再执行一次<strong>语句3</strong>的，所以以上代码解释如下：因为<strong>i–</strong>这个语句在每次循环开始前都会再次先用 <strong>i</strong> 是true和false来判断是否继续执行，这里同样要注意的是由于<strong>i–</strong>和<strong>–i</strong>的区别，这里由于是<strong>i–</strong>所以会先判断i的值再去做‘减减’的操作，所以这里最后如果打印 <strong>i</strong> 的值，会发现其实是<strong>-1</strong>。</p>
<p>####数组内置方法Array.prototype.forEach<br><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line">a.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value,key,arr</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(value)    <span class="comment">// 结果依次为1，2，3</span></div><div class="line">	<span class="built_in">console</span>.log(key)      <span class="comment">// 结尾依次为0，1，2</span></div><div class="line">	<span class="built_in">console</span>.log(arr)      <span class="comment">// 三次结果都为[1,2,3]，该参数貌似没什么用</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong><em>代码解读：</em></strong>forEach方法最大的好处就是便于使用，而且不用定义额外的参数变量，但是从效率以及性能角度来说它是劣于原始for循环的，而且也不能强制return结束循环，原因如下：<br>        <strong>forEach循环</strong>一看就是通过<strong>回调函数</strong>来提供参数的，而回调函数在JS中是<strong>闭包</strong>的一种，闭包的作用是用来生成<strong>私有作用域</strong>的，所以，每一个回调函数都是一个<strong>独立的作用域</strong>，都拥有自己独立的存储空间，互不影响，而且内部变量还不及时释放，这也就是为什么在能不用闭包的情况下就不要用闭包的原因，而在闭包中return的话，也只是在当前回调函数中返回了，可是forEach中的其他的回调函数（闭包）仍然存在，所以，导致return是没办法结束循环的。下面写一个forEach循环实现例子供大家参考理解：</p>
<p><strong><em>Example</em></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.forEachCopy = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> arr =  <span class="keyword">this</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</div><div class="line">				callback(arr[i],i,<span class="keyword">this</span>);</div><div class="line">		&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line">a.forEachCopy(<span class="function"><span class="keyword">function</span>(<span class="params">value,key,arr</span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(value)    <span class="comment">// 结果依次为1，2，3</span></div><div class="line">		<span class="built_in">console</span>.log(key)      <span class="comment">// 结尾依次为0，1，2</span></div><div class="line">		<span class="built_in">console</span>.log(arr)      <span class="comment">// 三次结果都为[1,2,3]</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>####数组内置方法Array.prototype.map</p>
<p><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> b = a.map(<span class="function"><span class="keyword">function</span>(<span class="params">value,key,arr</span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(value)    <span class="comment">// 结果依次为1，2，3</span></div><div class="line">		<span class="built_in">console</span>.log(key)      <span class="comment">// 结尾依次为0，1，2</span></div><div class="line">		<span class="built_in">console</span>.log(arr)      <span class="comment">// 三次结果都为[1,2,3]</span></div><div class="line">		<span class="keyword">return</span> value+<span class="number">1</span>;</div><div class="line">&#125;)</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 结果为[ 1, 2, 3 ]</span></div><div class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 结果为[ 2, 3, 4 ]</span></div></pre></td></tr></table></figure>
<p><strong><em>代码解读：</em></strong>map和forEach不同，在forEach中return语句是没有任何效果的，而map则可以<strong>改变当前循环的值</strong>，并且最终会<strong>返回一个新的被改变过值之后的数组</strong>（map如果不用return就和forEach一样了），由于这个特性，<strong>map一般用来处理需要修改某一个数组的值</strong>。map和forEach在其他的方面都是一样的，也不能return结束循环等特性，下面写一个map循环实现的例子供大家参考理解：<br><strong><em>Example</em></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.mapCopy = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> arr =  <span class="keyword">this</span>;</div><div class="line">		<span class="keyword">var</span> arrCopy = [];</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</div><div class="line">				<span class="keyword">var</span> cbValue = callback(arr[i],i,<span class="keyword">this</span>);</div><div class="line">				arrCopy.push(cbValue);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> arrCopy;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> b = a.mapCopy(<span class="function"><span class="keyword">function</span>(<span class="params">value,key,arr</span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(value)    <span class="comment">// 结果依次为1，2，3</span></div><div class="line">		<span class="built_in">console</span>.log(key)      <span class="comment">// 结尾依次为0，1，2</span></div><div class="line">		<span class="built_in">console</span>.log(arr)      <span class="comment">// 三次结果都为[1,2,3]</span></div><div class="line">		<span class="keyword">return</span> value+<span class="number">1</span>;</div><div class="line">&#125;)</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 结果为[ 1, 2, 3 ]</span></div><div class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 结果为[ 2, 3, 4 ]</span></div></pre></td></tr></table></figure>
<p>####数组内置方法Array.prototype.filter</p>
<p><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> b = a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">value,key,arr</span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(value)    <span class="comment">// 结果依次为1，2，3</span></div><div class="line">		<span class="built_in">console</span>.log(key)      <span class="comment">// 结尾依次为0，1，2</span></div><div class="line">		<span class="built_in">console</span>.log(arr)      <span class="comment">// 三次结果都为[1,2,3]</span></div><div class="line">		<span class="keyword">if</span>(value === <span class="number">3</span>)&#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;)</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 结果为[ 1, 2, 3 ]</span></div><div class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 结果为[ 1,2 ]</span></div></pre></td></tr></table></figure>
<p><strong><em>代码解读：</em></strong>filter和map不同，map目的是为了<strong>改变值</strong>，而filter目的是为了<strong>去掉不要的值</strong>，在循环的时候如果返回的是false那么就表示本次循环的不添加该值，返回true则相反是表示要添加到新建的数组中，下面写一个filter循环实现例子供大家参考：<br><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.filterCopy = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> arr =  <span class="keyword">this</span>;</div><div class="line">		<span class="keyword">var</span> arrCopy = [];</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</div><div class="line">				<span class="keyword">var</span> cbValue = callback(arr[i],i,<span class="keyword">this</span>);</div><div class="line">				<span class="keyword">if</span>(cbValue)&#123;</div><div class="line">					arrCopy.push(arr[i]);</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> arrCopy;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> b = a.filterCopy(<span class="function"><span class="keyword">function</span>(<span class="params">value,key,arr</span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(value)    <span class="comment">// 结果依次为1，2，3</span></div><div class="line">		<span class="built_in">console</span>.log(key)      <span class="comment">// 结尾依次为0，1，2</span></div><div class="line">		<span class="built_in">console</span>.log(arr)      <span class="comment">// 三次结果都为[1,2,3]</span></div><div class="line">		<span class="keyword">if</span>(value === <span class="number">3</span>)&#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;)</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 结果为[ 1, 2, 3 ]</span></div><div class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 结果为[ 1,2 ]</span></div></pre></td></tr></table></figure>
<p>####数组内置方法Array.prototype.reduce</p>
<p><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> b = a.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">count, value,key,arry</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(count);   <span class="comment">// 结果依次为0，1，3</span></div><div class="line">	<span class="built_in">console</span>.log(value);   <span class="comment">// 结果依次为1，2，3</span></div><div class="line">	<span class="built_in">console</span>.log(key);     <span class="comment">// 结果依次为0，1，2</span></div><div class="line">	<span class="built_in">console</span>.log(arry)     <span class="comment">// 三次结果都为[1,2,3]</span></div><div class="line">	<span class="keyword">return</span> count + value;</div><div class="line">&#125;,<span class="number">0</span>);</div><div class="line"><span class="built_in">console</span>.log(a);         <span class="comment">// 结果为[ 1, 2, 3 ]</span></div><div class="line"><span class="built_in">console</span>.log(b)          <span class="comment">// 结果为6</span></div></pre></td></tr></table></figure>
<p><strong><em>代码解读：</em></strong>reduce的不同之处在于累加，和其他几个内置方法不同的地方，它的第二个参数不是this对象，而是初始累加值（如果不设置的话数组会乱掉），而且回调函数的的个数也不同，比其他的多了一个，而且还在在开始的多加了一个参数，第一个参数记录的是上一次循环的累加值，下面写一个reduce循环实现例子供大家参考：<br><strong><em>Example</em></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.reduceCopy = <span class="function"><span class="keyword">function</span>(<span class="params">callback,countInit</span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> arr =  <span class="keyword">this</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</div><div class="line">				<span class="keyword">var</span> cbValue = callback(countInit,arr[i],i,<span class="keyword">this</span>);</div><div class="line">				countInit = cbValue;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> countInit;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> b = a.reduceCopy(<span class="function"><span class="keyword">function</span> (<span class="params">count, value,key,arry</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(count);   <span class="comment">// 结果依次为0，1，3</span></div><div class="line">	<span class="built_in">console</span>.log(value);   <span class="comment">// 结果依次为1，2，3</span></div><div class="line">	<span class="built_in">console</span>.log(key);     <span class="comment">// 结果依次为0，1，2</span></div><div class="line">	<span class="built_in">console</span>.log(arry)     <span class="comment">// 三次结果都为[1,2,3]</span></div><div class="line">	<span class="keyword">return</span> count + value;</div><div class="line">&#125;,<span class="number">0</span>);</div><div class="line"><span class="built_in">console</span>.log(a);         <span class="comment">// 结果为[ 1, 2, 3 ]</span></div><div class="line"><span class="built_in">console</span>.log(b)          <span class="comment">// 结果为6</span></div></pre></td></tr></table></figure>
<p>####数组内置方法Array.prototype.some<br><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> b = a.some(<span class="function"><span class="keyword">function</span>(<span class="params">value,key,arry</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(value);   <span class="comment">// 结果依次为1，2</span></div><div class="line">	<span class="built_in">console</span>.log(key);     <span class="comment">// 结果依次为0，1</span></div><div class="line">	<span class="built_in">console</span>.log(arry);    <span class="comment">// 两次次结果都为[1,2,3]</span></div><div class="line">	<span class="keyword">return</span> value===<span class="number">2</span>;</div><div class="line">&#125;)</div><div class="line"><span class="built_in">console</span>.log(a);         <span class="comment">// 结果为[ 1, 2, 3 ]</span></div><div class="line"><span class="built_in">console</span>.log(b);         <span class="comment">// 结果为true</span></div></pre></td></tr></table></figure>
<p><strong><em>代码解读：</em></strong>some的不同之处在它返回的布尔值，它的作用有点像filter，不过它的目的不是为了筛选返回数组，而是为了筛选该数组是否有满足你要的值，而且找到符合条件的值返回了一次true之后就不会再继续执行了，下面写一个some循环实现例子供大家参考：</p>
<p><strong><em>Example</em></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.someCopy = <span class="function"><span class="keyword">function</span>(<span class="params">callback,countInit</span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> arr =  <span class="keyword">this</span>;</div><div class="line">		<span class="keyword">var</span> isBool = <span class="literal">false</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</div><div class="line">				<span class="keyword">var</span> cbValue = callback(arr[i],i,<span class="keyword">this</span>);</div><div class="line">				<span class="keyword">if</span>(cbValue)&#123;</div><div class="line">					isBool = <span class="literal">true</span>;</div><div class="line">					<span class="keyword">return</span> isBool</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> isBool;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> b = a.someCopy(<span class="function"><span class="keyword">function</span>(<span class="params">value,key,arry</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(value);   <span class="comment">// 结果依次为1，2</span></div><div class="line">	<span class="built_in">console</span>.log(key);     <span class="comment">// 结果依次为0，1</span></div><div class="line">	<span class="built_in">console</span>.log(arry);    <span class="comment">// 两次次结果都为[1,2,3]</span></div><div class="line">	<span class="keyword">return</span> value===<span class="number">2</span>;</div><div class="line">&#125;)</div><div class="line"><span class="built_in">console</span>.log(a);         <span class="comment">// 结果为[ 1, 2, 3 ]</span></div><div class="line"><span class="built_in">console</span>.log(b);         <span class="comment">// 结果为true</span></div></pre></td></tr></table></figure>
<p>####数组内置方法Array.prototype.every<br><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> b = a.every(<span class="function"><span class="keyword">function</span>(<span class="params">value,key,arry</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(value);   <span class="comment">// 结果依次为1，2</span></div><div class="line">	<span class="built_in">console</span>.log(key);     <span class="comment">// 结果依次为0，1</span></div><div class="line">	<span class="built_in">console</span>.log(arry);    <span class="comment">// 两次次结果都为[1,2,3]</span></div><div class="line">	<span class="keyword">return</span> value===<span class="number">2</span>;</div><div class="line">&#125;)</div><div class="line"><span class="built_in">console</span>.log(a);         <span class="comment">// 结果为[ 1, 2, 3 ]</span></div><div class="line"><span class="built_in">console</span>.log(b);         <span class="comment">// 结果为false</span></div></pre></td></tr></table></figure>
<p><strong><em>代码解读</em></strong>：其实从看例子可以看出来，some和every作用是一样的，只不过some当找到之后返回的是true，而every找到之后返回的是false而已,下面写一个every循环实现例子供大家参考：</p>
<p><strong><em>Example</em></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.everyCopy = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> arr =  <span class="keyword">this</span>;</div><div class="line">		<span class="keyword">var</span> isBool = <span class="literal">true</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</div><div class="line">				<span class="keyword">var</span> cbValue = callback(arr[i],i,<span class="keyword">this</span>);</div><div class="line">				<span class="keyword">if</span>(cbValue)&#123;</div><div class="line">					isBool = <span class="literal">false</span>;</div><div class="line">					<span class="keyword">return</span> isBool</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> isBool;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> b = a.everyCopy(<span class="function"><span class="keyword">function</span>(<span class="params">value,key,arry</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(value);   <span class="comment">// 结果依次为1，2</span></div><div class="line">	<span class="built_in">console</span>.log(key);     <span class="comment">// 结果依次为0，1</span></div><div class="line">	<span class="built_in">console</span>.log(arry);    <span class="comment">// 两次次结果都为[1,2,3]</span></div><div class="line">	<span class="keyword">return</span> value===<span class="number">2</span>;</div><div class="line">&#125;)</div><div class="line"><span class="built_in">console</span>.log(a);         <span class="comment">// 结果为[ 1, 2, 3 ]</span></div><div class="line"><span class="built_in">console</span>.log(b);         <span class="comment">// 结果为false</span></div></pre></td></tr></table></figure>
<p>####数组内置方法Array.prototype.indexOf<br><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> b = a.indexOf(<span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(a);         <span class="comment">// 结果为[ 1, 2, 3 ]</span></div><div class="line"><span class="built_in">console</span>.log(b);         <span class="comment">// 结果为1</span></div></pre></td></tr></table></figure>
<p><strong><em>代码解读</em></strong>：对于indexOf方法来说，在数组循环过程中会和传入的参数比对，如果是比对成功，那么终止循环，返回对比成功的下标，下面写一个indexOf循环实现例子供大家参考：</p>
<p><strong><em>Example</em></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.indexOfCopy = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> arr =  <span class="keyword">this</span>;</div><div class="line">		<span class="keyword">var</span> index = <span class="number">-1</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</div><div class="line">				<span class="keyword">if</span>(arr[i] === value)&#123;</div><div class="line">					index = i;</div><div class="line">					<span class="keyword">return</span> index</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> index;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> b = a.indexOfCopy(<span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(a);         <span class="comment">// 结果为[ 1, 2, 3 ]</span></div><div class="line"><span class="built_in">console</span>.log(b);         <span class="comment">// 结果为1</span></div></pre></td></tr></table></figure>
<p>####数组内置方法Array.prototype.lastIndexOf<br><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> b = a.lastIndexOf(<span class="number">1</span>);</div><div class="line"><span class="built_in">console</span>.log(a);         <span class="comment">// 结果为[ 1, 2, 3, 1 ]</span></div><div class="line"><span class="built_in">console</span>.log(b);         <span class="comment">// 结果为1</span></div></pre></td></tr></table></figure>
<p><strong><em>代码解读</em></strong>：lastIndexOf方法和indexOf作用一致，但查找方向不同，indexOf是正向查找，lastIndexOf是你像查找，找到之后返回成功的下标，下面写一个lastIndexOf循环实现例子供大家参考：</p>
<p><strong><em>Example</em></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.lastIndexOf = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> arr =  <span class="keyword">this</span>;</div><div class="line">		<span class="keyword">var</span> index = <span class="number">-1</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i=arr.length;i--;)&#123;</div><div class="line">				<span class="keyword">if</span>(arr[i] === value)&#123;</div><div class="line">					index = i;</div><div class="line">					<span class="keyword">return</span> index</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> index;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> b = a.lastIndexOf(<span class="number">1</span>);</div><div class="line"><span class="built_in">console</span>.log(a);         <span class="comment">// 结果为[ 1, 2, 3 , 1 ]</span></div><div class="line"><span class="built_in">console</span>.log(b);         <span class="comment">// 结果为3</span></div></pre></td></tr></table></figure>
<blockquote>
<p>小结：对于以上8个数组的内置方法，forEach方法仅仅只是为了循环，并不可以帮你做额外的事情；map方法相当于在循环的时候你告诉数组当前遍历的这个值需要改成什么样，那么它就会最后给什么样的数组；filter方法相当于在循环的时候数组遍历一个个对象，并问你这个是不是你要找的值，如果你说是，他就会给你返回一个到新的数组中，不是他就会剔除；reduce方法相当于循环遍历对象做统计（累加或者累减之类的）;some和every方法相当于在遍历的时候拿着一个个对象问你这个是不是你找的，只要你说了一遍是，那么他就会给你分别返回的是true和false；indexOf和lastIndexOf方法相当于你告诉它你要找什么值，找到之后立马返回给你它的门牌号。</p>
</blockquote>
<p>####循环语句for…in</p>
<p><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> a)&#123;</div><div class="line">	<span class="built_in">console</span>.log(key); <span class="comment">//结果为依次为0，1，2</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> b = &#123;<span class="number">0</span>:<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>,<span class="number">2</span>:<span class="number">3</span>&#125;;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> b)&#123;</div><div class="line">	<span class="built_in">console</span>.log(key); <span class="comment">//结果为依次为0，1，2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码解读</em></strong>：从结果得知,for…in遍历数组的时候是遍历数组的下标值，而在遍历对象的时候遍历的是key值，所以猜想，数组在JS中，本质上也是一个以键值对形式存在的对象，而为了证明这点，我们做如下一个例子的实验：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [];</div><div class="line">a[<span class="string">'b'</span>] = <span class="number">2</span>;</div><div class="line"><span class="built_in">console</span>.log(a);     <span class="comment">//结果为[ b: 2 ]</span></div><div class="line"><span class="built_in">console</span>.log(a[<span class="number">0</span>]);  <span class="comment">//结果为undefined</span></div></pre></td></tr></table></figure>
<p>我们发现数组的下标不在对应相应位置的值了，由此可以证明在JS中数组其实本质上就是一个以<strong>下标为key值</strong>的对象。<br>当然对于for…in循环语句本身而言，它是一个浅度遍历对象的循环语句，值遍历第一层节点（当然对象中设置不可枚举的属性的除外）。<br><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;<span class="attr">b</span>:&#123;<span class="attr">c</span>:<span class="number">2</span>&#125;,<span class="attr">d</span>:&#123;<span class="attr">c</span>:<span class="number">4</span>&#125;&#125;;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> a)&#123;</div><div class="line">	<span class="built_in">console</span>.log(key); <span class="comment">//结果为依次为b,d</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>####ES6循环for…of语句<br><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> value <span class="keyword">of</span> a)&#123;</div><div class="line">	<span class="built_in">console</span>.log(value)  <span class="comment">// 结果依次为1，2，3</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码解读：</em></strong>for…of语句看着有点像for…in语句，但是和for…in语句不同的是它不可以循环对象，只能循环数组。</p>
]]></content>
      
        
        <tags>
            
            <tag> 数组遍历 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一段代码阐述一个轮播思路]]></title>
      <url>/2017/08/22/%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E9%98%90%E8%BF%B0%E4%B8%80%E4%B8%AA%E8%BD%AE%E6%92%AD%E6%80%9D%E8%B7%AF/</url>
      <content type="html"><![CDATA[<h1 id="一段代码阐述一个轮播思路"><a href="#一段代码阐述一个轮播思路" class="headerlink" title="一段代码阐述一个轮播思路"></a>一段代码阐述一个轮播思路</h1><p>####不BB，直接上代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> <span class="keyword">if</span> (direction === <span class="string">'next'</span>) &#123;</div><div class="line"><span class="number">2.</span>     <span class="keyword">this</span>.index = nextIndex;</div><div class="line"><span class="number">3.</span>     <span class="comment">/*如果是下一个，那就先吧下个的dom设置成none来移动位置，防止用户看到*/</span></div><div class="line"><span class="number">4.</span>     nextEl.style.display = <span class="string">'none'</span>;</div><div class="line"><span class="number">5.</span>     nextEl.style.webkitTransition = <span class="string">''</span>;</div><div class="line"><span class="number">6.</span>     currentEl.style.display = <span class="string">'block'</span>;</div><div class="line"><span class="number">7.</span>     currentEl.style.webkitTransition = <span class="string">'-webkit-transform '</span> + <span class="keyword">this</span>.speed + <span class="string">'ms ease-in-out'</span>;</div><div class="line"><span class="number">8.</span>     setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</div><div class="line"><span class="number">9.</span>         <span class="comment">/*将下个放到指定的位置*/</span></div><div class="line"><span class="number">10.</span>         nextEl.style.webkitTransform = <span class="keyword">this</span>.toward === <span class="string">'horizontal'</span> ? <span class="string">`translate3d(100%, 0, 0)`</span> : <span class="string">`translate3d(0, 100%, 0)`</span>;</div><div class="line"><span class="number">11.</span>         nextEl.style.display = <span class="string">'block'</span>;</div><div class="line"><span class="number">12.</span>         nextEl.style.webkitTransition = <span class="string">'-webkit-transform '</span> + <span class="keyword">this</span>.speed + <span class="string">'ms ease-in-out'</span>;</div><div class="line"><span class="number">13.</span>         setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line"><span class="number">14.</span>             <span class="comment">/*开始轮播*/</span></div><div class="line"><span class="number">15.</span>             currentEl.style.webkitTransform = <span class="keyword">this</span>.toward === <span class="string">'horizontal'</span> ? <span class="string">`translate3d(-100%, 0, 0)`</span> : <span class="string">`translate3d(0, -100%, 0)`</span>;</div><div class="line"><span class="number">16.</span>             nextEl.style.webkitTransform = <span class="string">`translate3d(0, 0, 0)`</span>;</div><div class="line"><span class="number">17.</span>         &#125;, <span class="number">20</span>);</div><div class="line"><span class="number">18.</span>     &#125;, <span class="number">10</span>);</div><div class="line"><span class="number">19.</span> &#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>注意</strong>：以上只是主思路代码，完整的代码解读完之后会贴出来供大家参考。<br><a id="more"></a><br><strong>代码解读：</strong>思路是先判断<strong>滚动方向</strong>，如果是向<strong>下一个节点</strong>那我就准备<strong>下一个节点到指定位置</strong>（仅适合界面一次展示一个轮播节点），如果直接移动到指定位置肯定是不合理的，因为节点直接移动会让用户在浏览器界面看到，可是节点是肯定要移动啊，思路很简单，那我给节点穿一件隐身衣（display:none）,之后再移动到指定位置用户不就看不到了，但是注意这里存在一个问题，如果直接设置设置display：none之后立马就移动位置的话会存在一个问题，移动的效果用户仍然能看的到，这是因为非异步的JS代码在执行的过程中是会阻止浏览器的绘图和重绘的，所以为了绕开浏览器这个机制那就使用异步好了（setTimeout）,下一个节点的位置现在已经准备好了，现在如果还是直接移动的话，又会存在一个问题下一个节点竟然看不到移动，这是因为我们在准备节点的节点的时候已经将它隐藏了，所以为了让用户看到就不得不把隐身衣脱了（display:block）才行，这样又得加一个异步（setTimeout）才能生效了，现在就可以安心的执行当前节点和早已就绪的下一个节点了。</p>
</blockquote>
<p>##完整代码如下：<br>下面的轮播JS部分的代码是vue写的，主要功能包括了垂直轮播，水平轮播，手势轮播等几个轮播的主要功能</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">	name: <span class="string">'swipe'</span>,</div><div class="line">	props: &#123;</div><div class="line">		<span class="comment">/*默认是水平滚动*/</span></div><div class="line">		toward: &#123;</div><div class="line">			type: <span class="built_in">String</span>,</div><div class="line">			<span class="keyword">default</span>: <span class="string">'vertical'</span></div><div class="line">		&#125;,</div><div class="line">		<span class="comment">/*是否展示指示标志*/</span></div><div class="line">		showIndicators: &#123;</div><div class="line">			type: <span class="built_in">Boolean</span>,</div><div class="line">			<span class="keyword">default</span>: <span class="literal">true</span></div><div class="line">		&#125;,</div><div class="line">		<span class="comment">/*滚动速度*/</span></div><div class="line">		speed: &#123;</div><div class="line">			type: <span class="built_in">Number</span>,</div><div class="line">			<span class="keyword">default</span>: <span class="number">300</span></div><div class="line">		&#125;,</div><div class="line">		<span class="comment">/*默认下标从哪儿开始*/</span></div><div class="line">		defaultIndex: &#123;</div><div class="line">			type: <span class="built_in">Number</span>,</div><div class="line">			<span class="keyword">default</span>: <span class="number">0</span></div><div class="line">		&#125;,</div><div class="line">		<span class="comment">/*自动滚动间隔*/</span></div><div class="line">		interval: &#123;</div><div class="line">			type: <span class="built_in">Number</span>,</div><div class="line">			<span class="keyword">default</span>: <span class="number">3000</span></div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	data() &#123;</div><div class="line">		<span class="keyword">return</span> &#123;</div><div class="line">			dots: [],    <span class="comment">// 页面标记圆点</span></div><div class="line">			index: <span class="keyword">this</span>.defaultIndex,   <span class="comment">//当前页面的下标</span></div><div class="line">			pageEls: [],   <span class="comment">// 所有的子轮播项集合</span></div><div class="line">			timer: <span class="literal">null</span>, <span class="comment">//轮播定时器对象</span></div><div class="line">			noSwipe: <span class="literal">false</span>,  <span class="comment">//禁止滚动</span></div><div class="line">			startPosition: <span class="string">''</span>,  <span class="comment">//touch的起始位置</span></div><div class="line">			currentPosition: <span class="string">''</span>,  <span class="comment">//touch的目前位置</span></div><div class="line">			translatePosition: <span class="string">''</span>,  <span class="comment">//touch位移的位置</span></div><div class="line">			distance: <span class="number">10</span>,    <span class="comment">//touch的位移大于10的时候生效</span></div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	watch: &#123;&#125;,</div><div class="line">	beforeMount: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	&#125;,</div><div class="line">	mounted()&#123;</div><div class="line">		<span class="keyword">this</span>.initSwipe();</div><div class="line">		<span class="keyword">this</span>.swipeTimeout();</div><div class="line">		<span class="keyword">this</span>.initTouchEvent();</div><div class="line">	&#125;,</div><div class="line">	computed: &#123;</div><div class="line">		getNum()&#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.pageEls.length;</div><div class="line">		&#125;,</div><div class="line">	&#125;,</div><div class="line">	methods: &#123;</div><div class="line">		<span class="comment">/*手动上一张*/</span></div><div class="line">		prev()&#123;</div><div class="line">			<span class="built_in">window</span>.clearTimeout(<span class="keyword">this</span>.timer);</div><div class="line">			<span class="keyword">this</span>.swipeTimeout(<span class="string">'prev'</span>);</div><div class="line">		&#125;,</div><div class="line">		<span class="comment">/*手动下一张*/</span></div><div class="line">		next()&#123;</div><div class="line">			<span class="built_in">window</span>.clearTimeout(<span class="keyword">this</span>.timer);</div><div class="line">			<span class="keyword">this</span>.swipeTimeout(<span class="string">'next'</span>);</div><div class="line">		&#125;,</div><div class="line">		initTouchEvent()&#123;</div><div class="line">			<span class="keyword">let</span> dom = <span class="keyword">this</span>.$el.querySelector(<span class="string">'.swipe-warp'</span>);</div><div class="line">			dom.addEventListener(<span class="string">'touchstart'</span>, <span class="keyword">this</span>.handleTouchStart);</div><div class="line">			dom.addEventListener(<span class="string">'touchmove'</span>, <span class="keyword">this</span>.handleTouchMove);</div><div class="line">			dom.addEventListener(<span class="string">'touchend'</span>, <span class="keyword">this</span>.handleTouchEnd);</div><div class="line">			<span class="built_in">console</span>.log(dom);</div><div class="line">		&#125;,</div><div class="line">		<span class="comment">/*初始化轮播节点*/</span></div><div class="line">		initSwipe()&#123;</div><div class="line">			<span class="keyword">var</span> children = <span class="keyword">this</span>.$children;</div><div class="line">			<span class="keyword">if</span> (children.length === <span class="number">1</span>) &#123;</div><div class="line">				<span class="keyword">this</span>.noSwipe = <span class="literal">false</span>;</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">			&#125;</div><div class="line">			children.forEach(<span class="function">(<span class="params">child, _index</span>)=&gt;</span> &#123;</div><div class="line">				<span class="keyword">this</span>.pageEls.push(child.$el);</div><div class="line">			&#125;);</div><div class="line">		&#125;,</div><div class="line">		<span class="comment">/*定时轮播*/</span></div><div class="line">		swipeTimeout(toward = <span class="string">'next'</span>)&#123;</div><div class="line">			<span class="keyword">this</span>.translate(toward, ()=&gt; &#123;</div><div class="line">				<span class="keyword">this</span>.timer = <span class="built_in">window</span>.setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</div><div class="line">					<span class="keyword">this</span>.swipeTimeout(<span class="string">'next'</span>);</div><div class="line">				&#125;, <span class="keyword">this</span>.interval);</div><div class="line">			&#125;);</div><div class="line">		&#125;,</div><div class="line">		<span class="comment">/*滚动方法*/</span></div><div class="line">		translate(direction = <span class="string">'next'</span>, cb)&#123;</div><div class="line">			<span class="keyword">let</span> length = <span class="keyword">this</span>.pageEls.length;</div><div class="line">			<span class="keyword">let</span> currentIndex = <span class="keyword">this</span>.index;</div><div class="line">			<span class="keyword">let</span> currentEl = <span class="keyword">this</span>.pageEls[currentIndex];</div><div class="line">			<span class="keyword">let</span> nextIndex = ((<span class="keyword">this</span>.index + <span class="number">1</span>) &gt; (length - <span class="number">1</span>)) ? <span class="number">0</span> : (<span class="keyword">this</span>.index + <span class="number">1</span>);</div><div class="line">			<span class="keyword">let</span> nextEl = <span class="keyword">this</span>.pageEls[nextIndex];</div><div class="line">			<span class="keyword">let</span> pervIndex = (<span class="keyword">this</span>.index - <span class="number">1</span>) &lt; <span class="number">0</span> ? (length - <span class="number">1</span>) : (<span class="keyword">this</span>.index - <span class="number">1</span>);</div><div class="line">			<span class="keyword">let</span> pervEl = <span class="keyword">this</span>.pageEls[pervIndex];</div><div class="line">			<span class="keyword">if</span> (direction === <span class="string">'next'</span>) &#123;</div><div class="line">				<span class="keyword">this</span>.index = nextIndex;</div><div class="line">				<span class="comment">/*如果是下一个，那就先吧下个的dom设置成none来移动位置，防止用户看到*/</span></div><div class="line">				nextEl.style.display = <span class="string">'none'</span>;</div><div class="line">				nextEl.style.webkitTransition = <span class="string">''</span>;</div><div class="line">				currentEl.style.display = <span class="string">'block'</span>;</div><div class="line">				currentEl.style.webkitTransition = <span class="string">'-webkit-transform '</span> + <span class="keyword">this</span>.speed + <span class="string">'ms ease-in-out'</span>;</div><div class="line">				setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</div><div class="line">					<span class="comment">/*将下个放到指定的位置*/</span></div><div class="line">					nextEl.style.webkitTransform = <span class="keyword">this</span>.toward === <span class="string">'horizontal'</span> ? <span class="string">`translate3d(100%, 0, 0)`</span> : <span class="string">`translate3d(0, 100%, 0)`</span>;</div><div class="line">					nextEl.style.display = <span class="string">'block'</span>;</div><div class="line">					nextEl.style.webkitTransition = <span class="string">'-webkit-transform '</span> + <span class="keyword">this</span>.speed + <span class="string">'ms ease-in-out'</span>;</div><div class="line">					setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">						<span class="comment">/*开始轮播*/</span></div><div class="line">						currentEl.style.webkitTransform = <span class="keyword">this</span>.toward === <span class="string">'horizontal'</span> ? <span class="string">`translate3d(-100%, 0, 0)`</span> : <span class="string">`translate3d(0, -100%, 0)`</span>;</div><div class="line">						nextEl.style.webkitTransform = <span class="string">`translate3d(0, 0, 0)`</span>;</div><div class="line">					&#125;, <span class="number">20</span>);</div><div class="line">				&#125;, <span class="number">10</span>);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				<span class="keyword">this</span>.index = pervIndex;</div><div class="line">				<span class="comment">/*如果是上一个，那就先吧上个的dom设置成none来移动位置，防止用户看到*/</span></div><div class="line">				pervEl.style.display = <span class="string">'none'</span>;</div><div class="line">				pervEl.style.webkitTransition = <span class="string">''</span>;</div><div class="line">				currentEl.style.display = <span class="string">'block'</span>;</div><div class="line">				currentEl.style.webkitTransition = <span class="string">'-webkit-transform '</span> + <span class="keyword">this</span>.speed + <span class="string">'ms ease-in-out'</span>;</div><div class="line">				setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</div><div class="line">					<span class="comment">/*将上个放到指定的位置*/</span></div><div class="line">					pervEl.style.webkitTransform = <span class="keyword">this</span>.toward === <span class="string">'horizontal'</span> ? <span class="string">`translate3d(-100%, 0, 0)`</span> : <span class="string">`translate3d(0, -100%, 0)`</span>;</div><div class="line">					pervEl.style.display = <span class="string">'block'</span>;</div><div class="line">					pervEl.style.webkitTransition = <span class="string">'-webkit-transform '</span> + <span class="keyword">this</span>.speed + <span class="string">'ms ease-in-out'</span>;</div><div class="line">					setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">						<span class="comment">/*开始轮播*/</span></div><div class="line">						currentEl.style.webkitTransform = <span class="keyword">this</span>.toward === <span class="string">'horizontal'</span> ? <span class="string">`translate3d(100%, 0, 0)`</span> : <span class="string">`translate3d(0, 100%, 0)`</span>;</div><div class="line">						pervEl.style.webkitTransform = <span class="string">`translate3d(0, 0, 0)`</span>;</div><div class="line">					&#125;, <span class="number">20</span>);</div><div class="line">				&#125;, <span class="number">10</span>);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">this</span>.once(currentEl, <span class="string">'webkitTransitionEnd'</span>, ()=&gt; &#123;</div><div class="line">				cb &amp;&amp; cb();</div><div class="line">			&#125;);</div><div class="line">		&#125;,</div><div class="line">		handleTouchStart($evnet)&#123;</div><div class="line">			<span class="keyword">this</span>.startPosition = <span class="keyword">this</span>.toward === <span class="string">'horizontal'</span> ? $evnet.touches[<span class="number">0</span>].clientX : $evnet.touches[<span class="number">0</span>].clientY;</div><div class="line">		&#125;,</div><div class="line">		handleTouchMove($evnet)&#123;</div><div class="line">			<span class="keyword">this</span>.currentPosition = <span class="keyword">this</span>.toward === <span class="string">'horizontal'</span> ? $evnet.touches[<span class="number">0</span>].clientX : $evnet.touches[<span class="number">0</span>].clientY;</div><div class="line">			<span class="keyword">this</span>.translatePosition = <span class="keyword">this</span>.currentPosition - <span class="keyword">this</span>.startPosition;</div><div class="line">			<span class="keyword">this</span>.translatePosition !== <span class="number">0</span> &amp;&amp; <span class="built_in">window</span>.clearTimeout(<span class="keyword">this</span>.timer);</div><div class="line">			$evnet.preventDefault();</div><div class="line">			$evnet.stopPropagation();</div><div class="line">		&#125;,</div><div class="line">		handleTouchEnd($evnet)&#123;</div><div class="line">			<span class="keyword">this</span>.translatePosition &lt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.translatePosition &lt; -<span class="keyword">this</span>.distance &amp;&amp; <span class="keyword">this</span>.swipeTimeout(<span class="string">'next'</span>);</div><div class="line">			<span class="keyword">this</span>.translatePosition &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.translatePosition &gt; <span class="keyword">this</span>.distance &amp;&amp; <span class="keyword">this</span>.swipeTimeout(<span class="string">'prev'</span>);</div><div class="line">		&#125;,</div><div class="line">		<span class="comment">/*管理事件*/</span></div><div class="line">		once(el, event, fn) &#123;</div><div class="line">			<span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">			<span class="keyword">var</span> listener = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">				<span class="keyword">if</span> (fn) &#123;</div><div class="line">					fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">				&#125;</div><div class="line">				that.off(el, event, listener);</div><div class="line">			&#125;;</div><div class="line">			<span class="keyword">this</span>.on(el, event, listener);</div><div class="line">		&#125;,</div><div class="line">		<span class="comment">/*监听事件*/</span></div><div class="line">		on(element, event, handler)&#123;</div><div class="line">			<span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</div><div class="line">				element.addEventListener(event, handler, <span class="literal">false</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;,</div><div class="line">		<span class="comment">/*移除事件*/</span></div><div class="line">		off(element, event, handler) &#123;</div><div class="line">			<span class="keyword">if</span> (element &amp;&amp; event) &#123;</div><div class="line">				element.removeEventListener(event, handler, <span class="literal">false</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 轮播 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[javaScript中数组排序详解]]></title>
      <url>/2017/08/22/javaScript%E4%B8%AD%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="javaScript中数组排序详解"><a href="#javaScript中数组排序详解" class="headerlink" title="javaScript中数组排序详解"></a>javaScript中数组排序详解</h1><p>####JS对于排序提供了一个Array.prototype.sort()方法，该方法提供了两种调用方式：</p>
<blockquote>
<p>Array.prototype.sort()<br>Array.prototype.sort(compareFunction)</p>
</blockquote>
<p>####对于第一种调用方式是默认调用方式，排序算法是根据<strong>Unicode码点</strong>并按照<strong>从小到大</strong>的方向排序。</p>
<p><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">4</span>,<span class="string">'a'</span>,<span class="number">3</span>];</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'4'</span>.charCodeAt());  <span class="comment">//码点52</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'3'</span>.charCodeAt());  <span class="comment">//码点结果51</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span>.charCodeAt());  <span class="comment">//码点结果97</span></div><div class="line"><span class="built_in">console</span>.log(a.sort());  <span class="comment">//结果为[3,4,'a']</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>####对于第二种调用方式是自定义排序规则，它接收的是一个函数。</p>
<p><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">4</span>,<span class="number">3</span>,<span class="string">'a'</span>];</div><div class="line"><span class="keyword">var</span> aTemp = a.sort(<span class="function">(<span class="params">k1,k2</span>)=&gt;</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">String</span>(k1).charCodeAt()&lt;<span class="built_in">String</span>(k2).charCodeAt();</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(aTemp); <span class="comment">//结果为['a',4,3]</span></div></pre></td></tr></table></figure>
<p><strong>注意</strong>：这里如果要比较的两个值不是都一样的，最好转成<strong>Unicode码点</strong>进行比较，这样不仅可以比较<strong>数字和字符串</strong>，也可以比较<strong>字符和数字</strong>。</p>
<blockquote>
<p>代码解读：Array.prototype.sort(compareFunction)采用的是冒泡排序算法，所以，传递给compareFunction函数的两个是数组中的遍历循环的一个个对象，也就是说，sort函数会将数组a的前两个对象4,3分别当参数传给compareFunction函数，并返回false，位置不变，所以，接着3会和’a’进行比较，返回true，调换位置，变成[4,’a’,3]，接着会比较4和’a’，返回true，调换位置，最终结果为[‘a’,4,3]</p>
</blockquote>
<p>####基于上面的理解附一个自己写的完美的sort比较函数，可以深度比较，以及支持多字段自定义比较，支持自定义降序和升序比较，有兴趣的可以阅读一下<br><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [</div><div class="line">	&#123;</div><div class="line">		name: <span class="string">'arvin'</span>,</div><div class="line">		year: <span class="number">10</span>,</div><div class="line">		cat: &#123;</div><div class="line">			len: <span class="string">'abc'</span></div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		name: <span class="string">'arvin2'</span>,</div><div class="line">		year: <span class="number">11</span>,</div><div class="line">		cat: &#123;</div><div class="line">			len: <span class="string">'abc'</span></div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		name: <span class="string">'arvin2'</span>,</div><div class="line">		year: <span class="number">11</span>,</div><div class="line">		cat: &#123;</div><div class="line">			len: <span class="string">'abcc'</span></div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">]</div><div class="line"><span class="comment">//获取对象的的key对应的值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">obj, key</span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) &#123;</div><div class="line">		<span class="built_in">console</span>.error(<span class="string">'不是对象'</span>);</div><div class="line">		<span class="keyword">return</span> <span class="literal">undefined</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">let</span> arrTemp = <span class="built_in">Object</span>.keys(obj);</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arrTemp) &#123;</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> obj[item] === <span class="string">'object'</span>) &#123;</div><div class="line">			<span class="keyword">return</span> getValue(obj[item], key);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (<span class="built_in">String</span>(item) === <span class="built_in">String</span>(key) &amp;&amp; <span class="keyword">typeof</span> obj[item] !== <span class="string">'object'</span>) &#123;</div><div class="line">			<span class="keyword">return</span> obj[item];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//比较两个字符串的Unicode大小</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compareUnicode</span>(<span class="params">str1, str2,rule</span>) </span>&#123;</div><div class="line"></div><div class="line">	str1 = <span class="built_in">String</span>(str1);</div><div class="line">	str2 = <span class="built_in">String</span>(str2);</div><div class="line">	<span class="keyword">let</span> len1 = str1.length;</div><div class="line">	<span class="keyword">let</span> len2 = str2.length;</div><div class="line">	<span class="keyword">let</span> len = len1 &gt; len2 ? len2 : len1;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> key = <span class="number">0</span>; key &lt; len; key++) &#123;</div><div class="line">		<span class="keyword">if</span> (<span class="built_in">Number</span>(<span class="built_in">String</span>(str1).charCodeAt(key)) !== <span class="built_in">Number</span>(<span class="built_in">String</span>(str2).charCodeAt(key))) &#123;</div><div class="line">			<span class="keyword">return</span> rule?<span class="built_in">Number</span>(<span class="built_in">String</span>(str1).charCodeAt(key)) &lt; <span class="built_in">Number</span>(<span class="built_in">String</span>(str2).charCodeAt(key)):<span class="built_in">Number</span>(<span class="built_in">String</span>(str1).charCodeAt(key)) &gt; <span class="built_in">Number</span>(<span class="built_in">String</span>(str2).charCodeAt(key));</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//判断如果str1没有大于str2</span></div><div class="line">		<span class="keyword">if</span> (key === len - <span class="number">1</span>) &#123;</div><div class="line">			<span class="comment">//判断长度</span></div><div class="line">			<span class="keyword">if</span> (len1 !== len2) &#123;</div><div class="line">				<span class="keyword">return</span> rule?len1&lt;len2:len1&gt;len2;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//深度排序数组（包括数组对象）</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepSortOn</span>(<span class="params">params</span>) </span>&#123;</div><div class="line">	<span class="keyword">let</span> compareFun = compareUnicode;</div><div class="line">	<span class="keyword">let</span> rule = !!params.rankRule;</div><div class="line">	<span class="keyword">let</span> arr = params.rankArray;</div><div class="line">	<span class="keyword">let</span> args = params.rankKeys &amp;&amp; params.rankKeys.split(<span class="string">','</span>);</div><div class="line">	<span class="keyword">if</span> (!(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>) || arr.length === <span class="number">0</span>) &#123;</div><div class="line">		<span class="built_in">console</span>.error(<span class="string">'只能比较并且数组不能为空'</span>);</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (arr.length === <span class="number">1</span> || !args || args.length === <span class="number">0</span>) &#123;</div><div class="line">		<span class="keyword">return</span> arr;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> arr.sort(<span class="function">(<span class="params">$item1, $item2</span>)=&gt;</span> &#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</div><div class="line">			<span class="keyword">if</span>(compareFun(getValue($item1, args[i]), getValue($item2, args[i]),rule) !== <span class="literal">null</span>)&#123;</div><div class="line">				<span class="keyword">return</span> compareFun(getValue($item1, args[i]), getValue($item2, args[i]),rule);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (args.length - <span class="number">1</span> === i) &#123;</div><div class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;)</div><div class="line">&#125;</div><div class="line"><span class="comment">//比较两个字符串的Unicode大小</span></div><div class="line"><span class="keyword">var</span> b = deepSortOn(&#123;</div><div class="line">	rankArray: a,</div><div class="line">	rankRule:<span class="literal">true</span>,</div><div class="line">	rankKeys: <span class="string">'year,name,len'</span>,</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(b); <span class="comment">//结果按照从小到大的顺序排列</span></div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从输入URL地址到显示完整的页面Webkit都做了哪些事情]]></title>
      <url>/2017/08/22/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%9C%B0%E5%9D%80%E5%88%B0%E6%98%BE%E7%A4%BA%E5%AE%8C%E6%95%B4%E7%9A%84%E9%A1%B5%E9%9D%A2Webkit%E9%83%BD%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85/</url>
      <content type="html"><![CDATA[<h1 id="从输入URL地址到显示完整的页面Webkit都做了哪些事情"><a href="#从输入URL地址到显示完整的页面Webkit都做了哪些事情" class="headerlink" title="从输入URL地址到显示完整的页面Webkit都做了哪些事情"></a>从输入URL地址到显示完整的页面Webkit都做了哪些事情</h1><h3 id="从输入地址到获取到数据的流程"><a href="#从输入地址到获取到数据的流程" class="headerlink" title="从输入地址到获取到数据的流程"></a>从输入地址到获取到数据的流程</h3><p>1、输入URL地址,如：<a href="http://www.yejm16361.com/demo/index.html。" target="_blank" rel="external">http://www.yejm16361.com/demo/index.html。</a></p>
<p>2、DNS解析URL地址中的域名返回IP地址（如果是主机名是IP地址就跳过该步骤）。</p>
<p>3、 建立TCP连接，这就是经典的<strong>TCP连接中的三次握手</strong>，总的来说作用就是为了<strong>在不可靠信道上能够可靠的传输</strong>。</p>
<p>4、浏览器向 web 服务器发送一个 HTTP 请求命令，如：GET/demo/index.html HTTP/1.1。</p>
<p>5、浏览器向 web 服务器发送请求头信息。</p>
<p>6、Web服务器应答，如：HTTP/1.1 200 OK，包含<strong>应答协议版本号和状态码</strong>。</p>
<p>7、Web服务器发送应答头信息。</p>
<p>8、Web服务器向浏览器发送数据。</p>
<p>9、Web服务器关闭TCP连接（如果浏览器或者服务器在其头信息加入了这行代码：<strong>Connection:keep-alive就延时跳过该步骤，超时仍然会关闭TCP连接，超时时间一般是5秒或15秒</strong>）。<br><a id="more"></a></p>
<p>###从获取到数据到显示最终完整页面的流程</p>
<p><img src="https://sfault-image.b0.upaiyun.com/779/339/779339663-5494140b11672" alt=""></p>
<p>1、在输入URL之后，<strong>依赖网络模块</strong>，webkit资源加载器加载HTML网页（只要是webkit能够解析的，都会把输入的URL地址资源当成HTML解析）。</p>
<p>2、<strong>加载完</strong>HTML网页之后，就会调动<strong>HTML解析器</strong>去<strong>解析构建节点</strong>。</p>
<p>3、解析期间如果遇到<strong>link</strong>节点，就会调用<strong>资源加载器</strong>去<strong>异步加载</strong>，完成之后用<strong>css解析器解析执行</strong>；如果是<strong>行内样式</strong>，会立即交给<strong>CSS解析器解析执行</strong>。这里CSS解析器，解析结果会生成一个<strong>css rule tree（css规则树）</strong>。</p>
<p>4、解析期间如果遇到<strong>script</strong>节点，就调用<strong>javascript解析器</strong>去<strong>解析并执行</strong>，这里注意的是如果是<strong>src脚本</strong>，那么在设置了<strong>H5新加的async属性</strong>的时候会<strong>异步加载加载并执行</strong>，否则会<strong>同步加载解析并执行</strong>，且<strong>阻塞dom树的创建</strong>；如果是<strong>行内脚本</strong>，那么无论怎么设置都会<strong>立即解析并执行</strong>，且<strong>阻塞dom树的创建</strong>。这里Javascript脚本执行主要是通过<strong>DOM API和CSSOM API来操作DOM树和CSS规则树</strong>。</p>
<p>5、解析期间如果遇到节点会依赖<strong>其他资源</strong>，如：图片，视屏，语音等，webkit会调用<strong>相应的加载器利用网络模块</strong>，去<strong>异步加载解析</strong>。</p>
<p>6、等到<strong>所有的同步和异步资源解析完成</strong>之后，浏览器引擎会把DOM树中<strong>无需渲染的节点</strong>（如display:none修饰的节点）不放进<strong>Rendering Tree（渲染树）</strong>中，并把<strong>CSS规则树中的样式附加给渲染树相应的dom节点，然后计算每一个dom节点的位置，这也就是layout（布局）和reflow（重排，回流）过程</strong>。</p>
<p>###附录：</p>
<p>####URL地址<br>这里的URL表示统一资源定位符，包含：</p>
<blockquote>
<p>1、传送协议（一般包括http、https、ftp、gopher、telnet、file等）<br>2、服务器（域名或IP地址），如果这里是域名的话，那么需要经过一个DNS查询的过程，详情见下面的DNS解析过程。<br>3、端口号（如果是HTTP默认是80端口，如果是HTTPS默认是443），可选<br>4、资源路径（path），上面的/demo/index.html就是路径，可选<br>5、参数(parameters)，可选<br>6、查询(query)，可选<br>7、信息片断（fragment），可选</p>
</blockquote>
<p>####DNS解析过程</p>
<ul>
<li>终端向Local DNS发起域名解析请求（这一步包含了查询浏览器缓存&gt;本地系统缓存&gt;路由器缓存）;</li>
<li>Local DNS在获取到域名解析请求后首先从Root hints获取根域名服务器的地址（Root hints包含了互联网DNS根服务器的地址信息）；</li>
<li>获取了根域名服务器地址后Local DNS向根域名服务器发起DNS解析请求，根域名服务器返回com顶级域名服务器地址；</li>
<li>随后Local DNS向com域名服务器发起解析请求，并得到taobao.com二级域名服务器的地址；</li>
<li>Local DNS向taobao.com二级域名服务器发起解析请求，并最终获得了www.taobao.com的IP地址信息；</li>
</ul>
<h4 id="常见的-Web-请求头信息"><a href="#常见的-Web-请求头信息" class="headerlink" title="常见的 Web 请求头信息"></a>常见的 Web 请求头信息</h4><p>请求头信息一般包括了：</p>
<blockquote>
<p>1、Method: 请求类型，常用的有get,post等。<br>2、Accept：浏览器可接受的MIME类型<br>3、Accept-Charset：浏览器可接受的字符集<br>4、Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip<br>5、Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。<br>6、Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中<br>7、Connection：表示是否需要持久连接。<br>8、Content-Length：表示请求消息正文的长度。<br>9、Content-Type：表示请求消息类型，常用的类型包括以下四种：application/x-www-form-urlencoded，multipart/form-data，application/json，text/xml。<br>10、Cookie：本地Cookie的缓存信息。<br>11、From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。<br>12、Host：初始URL中的主机和端口。<br>13、If-Modified-Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答。<br>14、Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝。<br>15、Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。<br>16、User-Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。<br>17、UA-Pixels，UA-Color，UA-OS，UA-CPU：由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型。</p>
</blockquote>
<p>####常见的服务端应答头信息<br> 应答头信息一般包含：</p>
<blockquote>
<p>1、Allow：服务器支持哪些请求方法（如GET、POST等）。<br>2、Content-Encoding：文档的编码（Encode）方法。<br>3、Content-Length：表示内容长度。<br>4、Content- Type： 表示后面的文档属于什么MIME类型。<br>5、Date：当前的GMT时间。<br>6、Expires：应该在什么时候认为文档已经过期，从而不再缓存它？<br>7、Last-Modified：文档的最后改动时间。<br>8、Location：表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。<br>9、Refresh：表示浏览器应该在多少时间之后刷新文档，以秒计。<br>10、Server：服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。<br>11、Set-Cookie：设置和页面关联的Cookie。<br>12、WWW-Authenticate：客户应该在Authorization头中提供什么类型的授权信息。<br>13、Access-Control-Allow-Credentials：是否跨域受信，可以跨域携带cookie信息。<br>14、Access-Control-Allow-Headers：跨域头信息设置。<br>15、Access-Control-Allow-Methods：允许跨域的方法请求。<br>16、Access-Control-Allow-Origin：允许跨域的客户端主机地址。<br>17、Access-Control-Max-Age：允许跨域连接有效时间。</p>
</blockquote>
<p>####reflow（重排）和repaint（重绘）区别，以及如何避免</p>
<p>常见触发repaint场景：</p>
<blockquote>
<p>1、color的修改，如color=#ddd；<br>2、text-align的修改，如text-align=center；<br>3、a:hover也会造成重绘。<br>4、:hover引起的颜色等不导致页面回流的style变动。</p>
</blockquote>
<p>常见触发reflow场景：</p>
<blockquote>
<p>1、width/height/border/margin/padding的修改，如width=778px；<br>2、动画，:hover等伪类引起的元素表现改动，display=none等造成页面回流；<br>3、appendChild等DOM元素操作；<br>4、font类style的修改；<br>5、background的修改，注意着字面上可能以为是重绘，但是浏览器确实回流了，经过浏览器厂家的优化，部分background的修改只触发repaint，当然IE不用考虑；<br>6、scroll页面，这个不可避免；<br>7、resize页面，桌面版本的进行浏览器大小的缩放，移动端的话，还没玩过能拖动程序，resize程序窗口大小的多窗口操作系统。<br>8、读取元素的属性（这个无法理解，但是技术达人是这么说的，那就把它当做定理吧）：读取元素的某些属性（offsetLeft、offsetTop、offsetHeight、offsetWidth、scrollTop/Left/Width/Height、clientTop/Left/Width/Height、getComputedStyle()、currentStyle(in IE))；</p>
</blockquote>
<p>如何避免：</p>
<blockquote>
<p>1、尽可能在DOM末梢通过改变class来修改元素的style属性：尽可能的减少受影响的DOM元素。<br>避免设置多项内联样式：使用常用的class的方式进行设置样式，以避免设置样式时访问DOM的低效率。<br>2、设置动画元素position属性为fixed或者absolute：由于当前元素从DOM流中独立出来，因此受影响的只有当前元素，元素repaint。<br>3、牺牲平滑度满足性能：动画精度太强，会造成更多次的repaint/reflow，牺牲精度，能满足性能的损耗，获取性能和平滑度的平衡。<br>4、避免使用table进行布局：table的每个元素的大小以及内容的改动，都会导致整个table进行重新计算，造成大幅度的repaint或者reflow。改用div则可以进行针对性的repaint和避免不必要的reflow。<br>5、避免在CSS中使用运算式：学习CSS的时候就知道，这个应该避免，不应该加深到这一层再去了解，因为这个的后果确实非常严重，一旦存在动画性的repaint/reflow，那么每一帧动画都会进行计算，性能消耗不容小觑。</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> webkit </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6解构赋值]]></title>
      <url>/2017/08/22/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
      <content type="html"><![CDATA[<h1 id="ES6解构赋值"><a href="#ES6解构赋值" class="headerlink" title="ES6解构赋值"></a>ES6解构赋值</h1><p>ES6变量的解构赋值本质上是“模式匹配”,只要等号两边的模式相同，左边的变量就会被赋予匹配的右边的值，如果匹配不成功变量的值就等于undefined</p>
<p>##数组的解构赋值<br>ES6中只要某种数据有Iterator接口（也就是可以循环迭代），都可以进行数组的解构赋值。<br><strong>Example1</strong>：数组的解构</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> [d,[e],...f] = [<span class="number">4</span>,[<span class="number">5</span>],<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">//结果为1，b,c结果是2，3</span></div><div class="line"><span class="built_in">console</span>.log(e,f) <span class="comment">//e结果为5，f的结果是一个数组：[6,7,8]</span></div></pre></td></tr></table></figure>
<p><strong>Example2</strong>：Set解构赋值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x,y] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>]);</div><div class="line"><span class="built_in">console</span>.log(x,y);   <span class="comment">//结果为1和2</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>Example3</strong>：Generator函数解构赋值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">let</span> a = <span class="number">0</span>;</div><div class="line">	<span class="keyword">let</span> b = <span class="number">1</span>;</div><div class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">		<span class="keyword">yield</span> a;</div><div class="line">		[a,b] = [b,a+b];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> [first,second,third,fourth,fifth,sixth] = fun();</div><div class="line"><span class="built_in">console</span>.log(sixth); <span class="comment">//结果为5</span></div></pre></td></tr></table></figure>
<p>Example4：默认值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> [a=<span class="number">3</span>,b=<span class="number">5</span>] = [<span class="literal">undefined</span>,<span class="number">4</span>];</div><div class="line"><span class="built_in">console</span>.log(a,b); <span class="comment">//结果为3和4</span></div></pre></td></tr></table></figure>
<p><strong><em>代码解读</em></strong>：上面的代码等同于如下：<br><strong><em>Example4</em></strong>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a;</div><div class="line"><span class="keyword">var</span> b;</div><div class="line"><span class="keyword">var</span> c = [<span class="literal">undefined</span>,<span class="number">4</span>];  <span class="comment">//这步骤是另加上去作为数组引用的</span></div><div class="line"><span class="keyword">if</span>(c[<span class="number">0</span>] !== <span class="literal">undefined</span>)&#123;</div><div class="line">	a = c[<span class="number">0</span>];</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">	a = <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(c[<span class="number">1</span>] !== <span class="literal">undefined</span>)&#123;</div><div class="line">	b = c[<span class="number">1</span>];</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">	b = <span class="number">5</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(a,b);   <span class="comment">//结果为3，4</span></div></pre></td></tr></table></figure>
<p>##对象的解构赋值<br>数组的解构是按次序排列的，变量取值由位置决定的，而对象的属性是没有顺序的，<strong>变量</strong>必须与<strong>属性同名</strong>才能取到正确的值。</p>
<p><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> &#123;b,a&#125; = &#123;<span class="attr">a</span>:<span class="number">3</span>,<span class="attr">b</span>:<span class="number">4</span>&#125;</div><div class="line"><span class="built_in">console</span>.log(a,b);   <span class="comment">//结果为3，4</span></div></pre></td></tr></table></figure>
<p><strong><em>代码解读</em></strong>：上面的代码等同下面的代码<br><strong><em>Example</em></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _ab = &#123;<span class="attr">a</span>:<span class="number">3</span>,<span class="attr">b</span>:<span class="number">4</span>&#125;;</div><div class="line"><span class="keyword">var</span> b = _ab.b;</div><div class="line"><span class="keyword">var</span> a = _ab.a;</div><div class="line"><span class="built_in">console</span>.log(a,b);   <span class="comment">//结果为3，4</span></div></pre></td></tr></table></figure>
<p><strong>注意</strong>：对象的解构相当于先定义了后一个对象变量为<strong>_ab</strong>，再对前一个对象<strong>解构</strong>出来的变量按照<strong>对象先后顺序</strong>分别进行<strong>申明</strong>并使用对象_ab去按照该<strong>变量名赋值</strong>相应的值。如果前一个对象中的<strong>变量</strong>和后一个对象中的<strong>属性</strong>不一致，直接定义是肯定赋值失败的，解决方法如下：<br><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> &#123;<span class="attr">b</span>:c,<span class="attr">a</span>:d&#125; = &#123;<span class="attr">a</span>:<span class="number">3</span>,<span class="attr">b</span>:<span class="number">4</span>&#125;;</div><div class="line"><span class="built_in">console</span>.log(b,c,a,d)    <span class="comment">// 分别是undefined,4,undefined,3</span></div></pre></td></tr></table></figure>
<p><strong><em>代码解读</em></strong>：上面代码等同下面的代码</p>
<p><strong><em>Example</em></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _ab = &#123;<span class="attr">a</span>:<span class="number">3</span>,<span class="attr">b</span>:<span class="number">4</span>&#125;;</div><div class="line"><span class="keyword">var</span> c = _ab.b;</div><div class="line"><span class="keyword">var</span> d = _ab.a;</div><div class="line"><span class="built_in">console</span>.log(b,c,a,d)    <span class="comment">// 分别是undefined,4,undefined,3</span></div></pre></td></tr></table></figure>
<p><strong>注意</strong>：例子可以看出对象的解构的内部机制是先找到<strong>同名属性</strong>，然后再赋予相应的变量，真正被赋予的是<strong>前一个对象</strong>的<strong>后一个变量</strong>，即<strong>c,d</strong>;而不是<strong>前一个对象</strong>的<strong>前一个模式</strong>，即<strong>b,a</strong>;</p>
<p>####发现：如果想要上一个例子的<strong>模式</strong>不为<strong>undefined</strong>，那么代码可以写成如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> e = &#123;<span class="attr">b</span>:c,<span class="attr">a</span>:d&#125; = &#123;<span class="attr">a</span>:<span class="number">3</span>,<span class="attr">b</span>:<span class="number">4</span>&#125;;</div><div class="line"><span class="built_in">console</span>.log(e.b,b,c,e.a,a,d)    <span class="comment">// 分别是4,undefined,4,3,undefined,3</span></div></pre></td></tr></table></figure>
<p><strong>注意</strong>：以上代码在使用babel转换的时候可能会出错，只在浏览器中有用，所以最好不要代码中使用，只理解就好</p>
<p>####对象解构赋值与数组解构赋值在申明的时候的一点区别：<br><strong>Example1</strong>：数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a;</div><div class="line">[a] = [<span class="number">3</span>]</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">//结果为3</span></div></pre></td></tr></table></figure>
<p><strong>Example2</strong>：对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a;</div><div class="line">&#123;a&#125; = &#123;<span class="attr">a</span>:<span class="number">3</span>&#125;</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 报错：SyntaxError</span></div></pre></td></tr></table></figure>
<p><strong><em>代码解读</em></strong>：JavaScript引擎会将<strong>[a]</strong>理解成一个数组，而将<strong>{a}</strong>理解成什么呢？对于<strong>{a}</strong>这个代码在JS中可能会存在两种解释，一种是它是一个<strong>表达式</strong>，表示含有a属性的一个<strong>对象</strong>；第二种它是一个<strong>语句(代码块)</strong>，为了消除这种歧义，js开发人员规定只要<strong>行首是大括号</strong>的，一律解析成<strong>代码块</strong>。解决上诉问题的代码如下：<br><strong><em>Example3</em></strong>：对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a;</div><div class="line">(&#123;a&#125; = &#123;<span class="attr">a</span>:<span class="number">3</span>&#125;)   <span class="comment">//JS中括号中的都是表达式</span></div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 结果3</span></div></pre></td></tr></table></figure>
<p>###解构赋值中的圆括号问题<br><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [(a)] = [<span class="number">1</span>];</div><div class="line"><span class="keyword">let</span> &#123;(b):c&#125; = &#123;<span class="attr">b</span>:<span class="number">2</span>&#125;;</div><div class="line"><span class="keyword">let</span> &#123;<span class="attr">d</span>:(e)&#125; = &#123;<span class="attr">d</span>:<span class="number">2</span>&#125;;    <span class="comment">//都报错：SyntaxError</span></div></pre></td></tr></table></figure>
<p><strong>注意</strong>：以上出现错误的原因都是：1、它们都是申明语句；2、圆括号中的都属于模式中的一部分。要同时不满足以上两个条件是比较困难的，所以，ES6规定，只要可能导致解构歧义就不得使用圆括号。所以，建议在写的过程中除了上面的那个对象圆括号的例子可以使用外，其他的情况都不能使用。</p>
<p>###ES6中还存在字符串、数组、布尔值等各种解构赋值，基本概念和原理都和对象的解构赋值类似，这里就不在全部列举了。</p>
]]></content>
      
        
        <tags>
            
            <tag> ES6解构赋值 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES5和ES6中的变量声明提升]]></title>
      <url>/2017/08/22/ES5%E5%92%8CES6%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87/</url>
      <content type="html"><![CDATA[<p>##ES5和ES6中的变量声明提升</p>
<p><strong>Example1</strong>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a=<span class="number">2</span>;</div><div class="line"><span class="keyword">var</span> a;</div><div class="line"><span class="built_in">console</span>.log( a );   <span class="comment">//结果为2</span></div></pre></td></tr></table></figure>
<p><strong>Example2</strong>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log( a );   <span class="comment">//结果是undefined</span></div><div class="line"><span class="keyword">var</span> a=<span class="number">2</span>;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>Example2</strong>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">foo();  <span class="comment">//结果是1</span></div><div class="line"><span class="keyword">var</span> foo;</div><div class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </div><div class="line">	<span class="built_in">console</span>.log( <span class="number">2</span> );</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </div><div class="line">	<span class="built_in">console</span>.log( <span class="number">1</span> );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>原理解读</em></strong>：浏览器引擎在运行程序分为两个阶段：第一个的阶段是<strong>编译阶段</strong>，该阶段负责找出代码中所有的<strong>定义声明</strong>（包括变量和函数），并关联到合适的<strong>作用域</strong>中；第二阶段是<strong>执行阶段</strong>，该阶段负责找出代码中的所有<strong>赋值声明</strong>，并在作用域找找到第一阶段的定义声明，以供使用。<br><strong><em>代码解读</em></strong>：<br><strong>第一个例子</strong>在编译阶段会将<strong>var a;</strong>这句<strong>定义声明</strong>首先解读关联到全局作用域中，所以当在<strong>赋值声明</strong>阶段执行<strong>a=2;</strong>和<strong>console.log(a);</strong>这两个赋值声明的代码时是正常执行的，也就有了<strong>定义声明提前</strong>了的感觉。</p>
<p><strong>第二个例子</strong>也同样是第一阶段先解读了<strong>var a</strong>,这部分<strong>定义声明</strong>，接着在第二阶段的时候执行<strong>console.log(a);</strong>的时候报<strong>undefined</strong>，说明虽然<strong>定义声明</strong>虽然提前了，可是<strong>赋值声明**</strong>a=2;**这部分仍然未提前。</p>
<p><strong>第三个例子</strong>在编译阶段会将 <strong>var foo;</strong>变量定义声明和 <strong>function foo(){…}</strong>函数定义声明提前，然后在第二阶段执行<strong>foo();</strong>赋值声明，这里需要注意的是在这种变量和函数重复声明的情况，函数定义申明会被<strong>提更前</strong>，原因倒不是真的是提前了，而只是在赋值声明的时候首先会去<strong>方法域</strong>中寻找，而后才去<strong>变量域</strong>中寻找，所以导致看起来是函数申明比变量声明更提前了。</p>
<p>###结论：对于JS中所说的变量声明提前，更准确的说法是变量定义声明提前了，更准确的理解是定义声明处于程序运行的第一个阶段导致相较于赋值声明的第二阶段有了<strong><em>前提</em></strong>的效果。</p>
]]></content>
      
        
        <tags>
            
            <tag> 变量声名 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vuex总结]]></title>
      <url>/2017/08/22/vuex%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><ul>
<li>作用：相当于vue中的data，用于存储状态，是<strong>唯一数据源</strong>，而是只读，不能做直接修改。</li>
<li>语法：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  state: &#123;</div><div class="line">    text:<span class="string">'hello world'</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li>调用：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法1</span></div><div class="line">store.state.text</div><div class="line"><span class="comment">// 方法2（需要使用vue.use注入）</span></div><div class="line"><span class="keyword">this</span>.$store.state.text</div><div class="line"><span class="comment">// 方法3，通过辅助函数mapState</span></div><div class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    computed: &#123;</div><div class="line">        <span class="comment">// 使用ES6的扩展运算符来达到将state释放出来</span></div><div class="line">        ...mapState([</div><div class="line">          <span class="comment">// 映射 this.text 为 store.state.text</span></div><div class="line">          <span class="string">'text'</span></div><div class="line">        ])</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意：</strong>如果一般state初始化时最好就设置好所需属性，如果真的需要动态需改某一个属性，可以如下：<br>1）Vue.set(obj, ‘newProp’, 123)<br>2）state.obj = { …state.obj, newProp: 123 }</p>
<h2 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h2><ul>
<li>作用：相当于vue中的computed，作用也是类似的。</li>
<li>语法：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  state: &#123;</div><div class="line">    text:<span class="string">'hello world'</span></div><div class="line">  &#125;,</div><div class="line">  getters: &#123;</div><div class="line">    <span class="comment">// 第一个参数固定是state对象，第二个参数固定是getters对象</span></div><div class="line">    getText: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> state.text + <span class="string">' xiaoming'</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// getters方法中调用getters方法</span></div><div class="line">    getGettersText: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> getters.getText;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// getters方法返回一个函数</span></div><div class="line">    getFuncText: <span class="function">(<span class="params">state,getters</span>) =&gt;</span> (name) =&gt; &#123;</div><div class="line">        <span class="keyword">return</span> state.text + <span class="string">' '</span> + name;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li>调用：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法1</span></div><div class="line">store.getters.getText</div><div class="line"><span class="comment">// 方法2</span></div><div class="line"><span class="keyword">this</span>.$store.getters.getText</div><div class="line"><span class="comment">// 方法3，通过辅助函数mapGetters</span></div><div class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    computed: &#123;</div><div class="line">        ...mapGetters([</div><div class="line">            <span class="string">'getText'</span>,</div><div class="line">            <span class="string">'getGettersText'</span>,</div><div class="line">            <span class="string">'getFuncText'</span></div><div class="line">        ])</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="mutation"><a href="#mutation" class="headerlink" title="mutation"></a>mutation</h2><ul>
<li><p>作用：相当于vue中data对象的的set方法，是唯一可以改变state数据的方式，定位是<strong>同步改变</strong>，即在mutation的方法中不支持异步逻辑，这个的具体原因是因为mutation类似于事件监听的回调函数，而任何在回调函数中进行的状态的改变都是不可追踪的。</p>
</li>
<li><p>语法：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  state: &#123;</div><div class="line">    text:<span class="string">'hello world'</span></div><div class="line">  &#125;,</div><div class="line">  mutations: &#123;</div><div class="line">    <span class="comment">// 第一个参数固定是state，剩下还可以再传入一个或0个参数（也叫载荷），这个载荷参数一般是对象，方便传入多个值</span></div><div class="line">    changeText (state, payload) &#123;</div><div class="line">      <span class="comment">// 变更状态</span></div><div class="line">      state.text = <span class="string">'welcome'</span> + payload.name;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li>调用：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法1，只是第二个参数是载荷</span></div><div class="line">store.commit(<span class="string">'changeText'</span>, &#123;</div><div class="line">    name: <span class="string">'xiaoye'</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">// 方法2，相当于整个对象都是载荷</span></div><div class="line">store.commit(&#123;</div><div class="line">    type: <span class="string">'changeText'</span>,</div><div class="line">    name: <span class="string">'xiaoye'</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">// 方法3</span></div><div class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'changeText'</span>, &#123;</div><div class="line">    name: <span class="string">'xiaoye'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 方法4，依赖辅助函数mapMutations </span></div><div class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  methods: &#123;</div><div class="line">  <span class="comment">// 将this.changeText(&#123;name: 'xiaoye'&#125;)映射为this.$store.commit('changeText', &#123;name: 'xiaoye'&#125;);</span></div><div class="line">    ...mapMutations([</div><div class="line">      <span class="string">'changeText'</span></div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><ul>
<li><p>作用：相当于vue中的method，<strong>不能</strong>直接修改state，<strong>只能</strong>通过调用mutation中的方法间接改变state，定位是<strong>异步改变</strong>，当然也可以同步，如果是需要异步改变的逻辑建议写在action中，其实用过action就知道，其实就相当于把本来属于vue中的method中的方法放到vuex中的action中来而已，只是说公共的异步请求不再用写那么多份在不同的method中，只需要写一份放在action中即可。</p>
</li>
<li><p>语法：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  state: &#123;</div><div class="line">    text:<span class="string">'hello world'</span></div><div class="line">  &#125;,</div><div class="line">  mutations: &#123;</div><div class="line">    <span class="comment">// 第一个参数固定是state，剩下还可以再传入一个或0个参数（也叫载荷），这个载荷参数一般是对象，方便传入多个值</span></div><div class="line">    changeText (state, payload) &#123;</div><div class="line">      <span class="comment">// 变更状态</span></div><div class="line">      state.text = <span class="string">'welcome'</span> + payload.name;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  actions: &#123;</div><div class="line">    <span class="comment">// 第一个参数是固定的一个类似store的实例，具有和store实例相同方法和属性，即可以直接调用state，getters，commit，dispatch等；第二个参数同mutations一样，是载荷</span></div><div class="line">    asynChangeText (context, payload) &#123;</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">          context.commit(<span class="string">'changeText'</span>, payload.asynName)</div><div class="line">        &#125;, <span class="number">1000</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li>调用：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法1</span></div><div class="line">store.dispatch(<span class="string">'asynChangeText'</span>, &#123;</div><div class="line">  asynName: <span class="string">'xiaoMing'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 方法2</span></div><div class="line">store.dispatch(&#123;</div><div class="line">  type: <span class="string">'asynChangeText'</span>,</div><div class="line">  asynName: <span class="string">'xiaoMing'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 方法3</span></div><div class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'asynChangeText'</span>, &#123;</div><div class="line">    asynName: <span class="string">'xiaoMing'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 方法4，依赖辅助函数mapActions</span></div><div class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  <span class="comment">// 用法同 mutation 一样</span></div><div class="line">  methods: &#123;</div><div class="line">    ...mapActions([</div><div class="line">      <span class="string">'asynChangeText'</span></div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><ul>
<li><p>作用：将<strong>state模块化和嵌套子模块化</strong>，避免state过大，而变得臃肿，不方便管理，每一个模块都包含完整的state、actions、mutations、getters。</p>
</li>
<li><p>语法1（默认命名空间）：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> ** 模块化（默认命名空间）</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">const</span> moduleA = &#123;</div><div class="line">  state: &#123;</div><div class="line">    a: <span class="number">1</span>,</div><div class="line">  &#125;,</div><div class="line">  mutations: &#123;</div><div class="line">    <span class="comment">// 该state包含的是本模块自己以及子模块的state</span></div><div class="line">    setA (state, payload) &#123;&#125;</div><div class="line">  &#125;,</div><div class="line">  actions: &#123;</div><div class="line">    <span class="comment">// 该context除包含本模块自己以及子模块的属性和方法外，还另外多包含rootGetters和rootState两个属性根模块（moduleA）的state和getter</span></div><div class="line">     getAsynA (context, payload) &#123;&#125;</div><div class="line">  &#125;,</div><div class="line">  getters: &#123;</div><div class="line">    <span class="comment">// 这里的rootState和rootGetter等同于根模块（moduleA）的state和getter</span></div><div class="line">    getA (state, getters, rootState, rootGetter) &#123;&#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 两个子模块</span></div><div class="line">  modules: &#123;</div><div class="line">    moduleB,</div><div class="line">    moduleC</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 和moduleA模块一样，只是rootState和rootGetter依然表示moduleA这个跟模块而已</span></div><div class="line"><span class="keyword">const</span> moduleB = &#123;</div><div class="line">  state: &#123;  &#125;,</div><div class="line">  mutations: &#123; ... &#125;,</div><div class="line">  actions: &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 同moduleB</span></div><div class="line"><span class="keyword">const</span> moduleC = &#123;</div><div class="line">  state: &#123; ... &#125;,</div><div class="line">  mutations: &#123; ... &#125;,</div><div class="line">  actions: &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(moduleA)</div></pre></td></tr></table></figure>
<p><strong>注意：</strong>在默认的命名空间中：<br>1）所有的模块和子模块的mutations和actions都是包含在全局中的，也叫在<strong>全局命名空间</strong>中。也就是说如果不同的模块中有相同的actions或者mutations是会存在重复注册挂载到全局中的情况的，只不过他们<strong>不是覆盖而是追加</strong>的关系而已，被调用的顺讯也是按照<strong>模块的注册顺序递归调用</strong>的。</p>
<p>2）所有模块和子模块的getters都是包含在全局中的，不过不同的是如果出现不同模块之间重名的情况，不是追加而是<strong>先到先得</strong>，即哪一个模块先注册，即使用谁的。</p>
<p>3）而state是仍然是划分模块的，外部如果要调用，调用方式也是按照<strong>模块的层级路径</strong>来调用的。即：<strong>moduleA的状态：store.state；moduleB的状态：store.state.moduleB</strong>。</p>
<ul>
<li>调用：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 调用state，方法1</span></div><div class="line">store.state.a</div><div class="line">store.state.moduleB.b</div><div class="line"><span class="comment">// 调用state，方法2</span></div><div class="line"><span class="keyword">this</span>.$store.state.a</div><div class="line"><span class="keyword">this</span>.$store.state.moduleB.b</div><div class="line"><span class="comment">// 调用state，方法3</span></div><div class="line"><span class="keyword">import</span> &#123;mapState&#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    computed: &#123;</div><div class="line">        ...mapState([</div><div class="line">            <span class="string">'a'</span>,        <span class="comment">// 是moduleA的state</span></div><div class="line">            <span class="string">'moduleB'</span>,   <span class="comment">// moduleB是一个对象，包含自己以及子模块的state</span></div><div class="line">            <span class="string">'c'</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.a.moduleC.c <span class="comment">// moduleC模块下的state可以通过这种方法的形式返回值</span></div><div class="line">        ])</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用getter，方法1</span></div><div class="line">store.getters.getA</div><div class="line">store.getters.getB</div><div class="line"><span class="comment">// 调用getter，方法2</span></div><div class="line"><span class="keyword">this</span>.$store.getters.getA</div><div class="line"><span class="keyword">this</span>.$store.getters.getB</div><div class="line"><span class="comment">// 调用getter，方法3</span></div><div class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    computed: &#123;</div><div class="line">        ...mapGetters([</div><div class="line">            <span class="string">'getA'</span>,</div><div class="line">            <span class="string">'getB'</span></div><div class="line">        ])</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用mutations，方法1，和getter相同点都是挂载在全局中，不同点是不同模块中存在相同名称是会按顺序触发的</span></div><div class="line">store.commit(<span class="string">'setA'</span>)</div><div class="line">store.commit(<span class="string">'setB'</span>)</div><div class="line"><span class="comment">// 调用mutations，方法2</span></div><div class="line">store.commit(&#123;</div><div class="line">    type: <span class="string">'setA'</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">// 调用mutations，方法3</span></div><div class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'setA'</span>)</div><div class="line"><span class="comment">// 调用mutations，方法4</span></div><div class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  methods: &#123;</div><div class="line">    ...mapMutations([</div><div class="line">      <span class="string">'setA'</span></div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用actions，同mutations一样</span></div></pre></td></tr></table></figure>
<ul>
<li>语法2（命名空间）：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> ** 模块化（命名空间）</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">const</span> moduleA = &#123;</div><div class="line">  namespaced: <span class="literal">true</span>,</div><div class="line">  state: &#123;</div><div class="line">    a: <span class="number">1</span>,</div><div class="line">  &#125;,</div><div class="line">  mutations: &#123;</div><div class="line">    <span class="comment">// 该state包含的是本模块自己以及子模块的state</span></div><div class="line">    setA (state, payload) &#123;&#125;</div><div class="line">  &#125;,</div><div class="line">  actions: &#123;</div><div class="line">    <span class="comment">// 该context除包含本模块自己以及子模块的属性和方法外，还另外多包含rootGetters和rootState两个属性根模块（moduleA）的state和getter</span></div><div class="line">     getAsynA (context, payload) &#123;&#125;</div><div class="line">  &#125;,</div><div class="line">  getters: &#123;</div><div class="line">    <span class="comment">// 这里的rootState和rootGetter等同于根模块（moduleA）的state和getter</span></div><div class="line">    getA (state, getters, rootState, rootGetter) &#123;&#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 两个子模块</span></div><div class="line">  modules: &#123;</div><div class="line">    moduleB,</div><div class="line">    moduleC</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 和moduleA模块一样，只是rootState和rootGetter依然表示moduleA这个跟模块而已</span></div><div class="line"><span class="keyword">const</span> moduleB = &#123;</div><div class="line">  <span class="comment">//  namespaced: true, // 这里如果不设置命名空间的话那moduleC就继承父命名空间</span></div><div class="line">  state: &#123;  &#125;,</div><div class="line">  mutations: &#123; ... &#125;,</div><div class="line">  actions: &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 同moduleB</span></div><div class="line"><span class="keyword">const</span> moduleC = &#123;</div><div class="line">  namespaced: <span class="literal">true</span>,</div><div class="line">  state: &#123; ... &#125;,</div><div class="line">  mutations: &#123; ... &#125;,</div><div class="line">  actions: &#123; ... &#125;,</div><div class="line">  modules: &#123;</div><div class="line">        moduleD: &#123;</div><div class="line">            namespaced: <span class="literal">true</span>,</div><div class="line">            state: &#123;</div><div class="line">                d: <span class="number">1</span>,</div><div class="line">            &#125;,</div><div class="line">            mutations: &#123;&#125;,</div><div class="line">            actions: &#123;&#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(moduleA)</div></pre></td></tr></table></figure>
<p><strong>注意：</strong>在命名空间中：<br>1）所有的模块和子模块的mutations、actions、getters都是包含在<strong>各自的命名空间或父命名空间中</strong>，即<strong>自动根据模块注册的路径调整命名</strong>。</p>
<p>2）而state不受影响，因为默认state也已经是层级嵌套的了。</p>
<ul>
<li>调用</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 调用state，方法4（前三个方法和默认命名空间类似）</span></div><div class="line">computed: &#123;</div><div class="line">  ...mapState(<span class="string">'moduleC/moduleD'</span>, &#123;</div><div class="line">    d: <span class="function"><span class="params">state</span> =&gt;</span> state.d</div><div class="line">  &#125;),</div><div class="line">  ...mapState(<span class="string">'moduleC/moduleD'</span>, [<span class="string">'d'</span>]) <span class="comment">// 这两种是一样的，只是写法不同</span></div><div class="line">&#125;,</div><div class="line"><span class="comment">// 调用state，方法5（通过辅助函数createNamespacedHelpers）</span></div><div class="line"><span class="keyword">import</span> &#123; createNamespacedHelpers &#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</div><div class="line"><span class="keyword">const</span> &#123; mapState &#125; = createNamespacedHelpers(<span class="string">'moduleC/moduleD'</span>);</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  computed: &#123;</div><div class="line">    <span class="comment">// 在 `moduleC/moduleD` 中查找</span></div><div class="line">    ...mapState(&#123;</div><div class="line">      d: <span class="function"><span class="params">state</span> =&gt;</span> state.d</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 其他的getter、mutations、actions也是和state类似的以上的方法</span></div></pre></td></tr></table></figure>
<h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><ul>
<li><p>作用：plugins 是vuex中的一个函数，一般配合 subscribe 函数实现类似于拦截器的效果，而且是一个成功之后的拦截器，是每次 mutation 调用成功之后的钩子，它接收store 实例作为作为唯一的参数。</p>
</li>
<li><p>语法：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> myPlugin = <span class="function"><span class="params">store</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// mutation 的格式为：&#123; type, payload &#125;，通过这个对象可以判断是哪一个 mutation 被调用了，额外的参数是什么。</span></div><div class="line">    store.subscribe(<span class="function">(<span class="params">mutation, state</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">if</span> (mutation.type === <span class="string">'updateA'</span>) &#123;</div><div class="line">            <span class="built_in">console</span>.log(mutation)</div><div class="line">            <span class="built_in">console</span>.log(state)</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> moduleA = &#123;</div><div class="line">    state: &#123;</div><div class="line">        a: <span class="number">1</span>,</div><div class="line">    &#125;,</div><div class="line">    mutations: &#123;</div><div class="line">        <span class="comment">// 被调用完成之后会触发 myPlugin 中的 subscribe 回调</span></div><div class="line">        updateA (context, payload) &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'A'</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    actions: &#123;...&#125;,</div><div class="line">    getters: &#123;...&#125;,</div><div class="line">    modules: &#123;...&#125;,</div><div class="line">    plugins: [myPlugin]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(moduleA);</div></pre></td></tr></table></figure>
<p><strong>注意：</strong>在插件中如果要修改state状态，也需要通过store调用commit，从而触发 mutation 改变state的状态，也就是说不能直接修改state状态。</p>
<h2 id="strict"><a href="#strict" class="headerlink" title="strict"></a>strict</h2><ul>
<li><p>上面一直强调就是修改只能在 mutations 中完成，为了强制约束，可是在vuex实例化的时候传入该属性（严格模式）。</p>
</li>
<li><p>语法</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> moduleA = &#123;</div><div class="line">    state: &#123;...&#125;,</div><div class="line">    mutations: &#123;...&#125;,</div><div class="line">    actions: &#123;...&#125;,</div><div class="line">    getters: &#123;...&#125;,</div><div class="line">    modules: &#123;...&#125;,</div><div class="line">    plugins: [...],</div><div class="line">    strict: <span class="literal">true</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(moduleA);</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> vuex </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[闭包]]></title>
      <url>/2017/08/22/%E9%97%AD%E5%8C%85/</url>
      <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p><strong>闭包的目的</strong>：封装内部实现，构建私有作用域， <em>暴露公有的API</em> 。<br><strong>闭包的晦涩定义</strong>：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。<br><strong>闭包的简单定义</strong>：一个函数中定义了另一个函数。<br><strong>Example1</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </div><div class="line">	<span class="keyword">var</span> a=<span class="number">2</span>;</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; </div><div class="line">		<span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></div><div class="line">	&#125;</div><div class="line">	bar(); </div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong><em>注意</em></strong>：<br><strong>Example2</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </div><div class="line">	<span class="keyword">var</span> a=<span class="number">2</span>;</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; </div><div class="line">		<span class="built_in">console</span>.log( a );</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> bar; </div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> baz = foo();</div><div class="line">baz(); <span class="comment">// 2 —— 这就是闭包的效果。</span></div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 闭包 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS创建对象的最好用的两种方式]]></title>
      <url>/2017/08/22/JS%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%80%E5%A5%BD%E7%94%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="组合使用构造函数模式和原型模式（最常用）"><a href="#组合使用构造函数模式和原型模式（最常用）" class="headerlink" title="组合使用构造函数模式和原型模式（最常用）"></a>组合使用构造函数模式和原型模式（最常用）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name</div><div class="line">  <span class="keyword">this</span>.friends = [‘Shelby’, ‘Court’]</div><div class="line">&#125;</div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person()</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person1.friends)  <span class="comment">//[“Shelby”, “Court”, “Van”]</span></div><div class="line"><span class="built_in">console</span>.log(person2.friends) <span class="comment">// [“Shelby”, “Court”]</span></div><div class="line"><span class="built_in">console</span>.log(person1.friends === person2.friends) <span class="comment">//false</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>优点：</strong>使用此模式可以让每个实例都会有自己的一份实例属性副本，但同时又共享着对方法的引用，这样的话，即使实例属性修改引用类型的值，也不会影响其他实例的属性值了</li>
</ul>
<h2 id="动态原型模式（红宝书认为最完美）"><a href="#动态原型模式（红宝书认为最完美）" class="headerlink" title="动态原型模式（红宝书认为最完美）"></a>动态原型模式（红宝书认为最完美）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, job</span>) </span>&#123;</div><div class="line">  <span class="comment">// 属性</span></div><div class="line">  <span class="keyword">this</span>.name = name</div><div class="line">  <span class="keyword">this</span>.job = job</div><div class="line">  </div><div class="line">  <span class="comment">// 方法</span></div><div class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName !== ‘<span class="function"><span class="keyword">function</span>’) </span>&#123;</div><div class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">    Person.prototype.writeName = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">       <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(‘Jiang’, ‘Student’)</div><div class="line">person1.sayName()</div></pre></td></tr></table></figure>
<ul>
<li><strong>优点：</strong>只有在sayName方法不存在的时候，才会将它添加到原型中。这段代码只会初次调用构造函数的时候才会执行。此后原型已经完成初始化，不需要在做什么修改了这里对原型所做的修改，能够立即在所有实例中得到反映。其次，if语句检查的可以是初始化之后应该存在的任何属性或方法，所以不必用一大堆的if语句检查每一个属性和方法，只要检查一个就行。</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 创建对象 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一段代码看出JS的的解析到执行的顺序规则]]></title>
      <url>/2017/08/22/%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E7%9C%8B%E5%87%BAJS%E7%9A%84%E7%9A%84%E8%A7%A3%E6%9E%90%E5%88%B0%E6%89%A7%E8%A1%8C%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A7%84%E5%88%99/</url>
      <content type="html"><![CDATA[<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    b = <span class="number">3</span>;</div><div class="line">    <span class="keyword">var</span> b;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 打印出：10</span></div><div class="line">    <span class="built_in">console</span>.log(b); <span class="comment">// 打印出：3</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">bar(<span class="number">10</span>);</div></pre></td></tr></table></figure>
<p>##执行顺序</p>
<h3 id="函数外面的时候，代码拆成前后两部分来看："><a href="#函数外面的时候，代码拆成前后两部分来看：" class="headerlink" title="函数外面的时候，代码拆成前后两部分来看："></a>函数外面的时候，代码拆成前后两部分来看：</h3><h4 id="第-1-部分：（申明）"><a href="#第-1-部分：（申明）" class="headerlink" title="第 1 部分：（申明）"></a>第 1 部分：（申明）</h4><ul>
<li>1、申明了一个<code>bar=undefined</code>的函数变量，用代码可以看成：（<code>VO</code>是执行上下文，可以看成是<code>this</code><br>）</li>
</ul>
<blockquote>
<p>VO = {bar:undefined}</p>
</blockquote>
<h4 id="第-2-部分：（执行）"><a href="#第-2-部分：（执行）" class="headerlink" title="第 2 部分：（执行）"></a>第 2 部分：（执行）</h4><ul>
<li>2、执行<code>bar(10)</code>这里由于是函数，存在独立作用域，只要存在作用域就先解析，所以这里又可以拆成两部分来看：</li>
</ul>
<h5 id="第-2-1-部分：（申明）"><a href="#第-2-1-部分：（申明）" class="headerlink" title="第 2.1 部分：（申明）"></a>第 2.1 部分：（申明）</h5><ul>
<li>先声明<code>a=10</code>,<code>b=undefined</code>两个形参变量，再申明函数变量<code>b=function b(){}</code>，由于上下文<code>VO1</code>中已经存在 <code>b</code> 了，所以会覆盖掉形参<code>b</code>的申明，然后再申明<code>var</code>变量<code>b=undefined</code>，并覆盖已经存在<code>VO1</code>中函数变量<code>b</code>，用代码表示：</li>
</ul>
<blockquote>
<p>VO1 = {a：10,b:undefined}</p>
</blockquote>
<p><strong>注意：</strong>这里需要注意的是<strong>函数表达式</strong><code>return function a(){}</code>并不会提前申明，<code>函数表达式</code>和<code>函数申明</code>的异同是，除了标准的<code>函数申明</code>：<code>function a(){}</code>，其他的都是<code>函数表达式</code>，如：<code>var a = function (){}</code>、<code>(function a(){})</code>…等。<br><strong>注意：</strong>申明的权重：<strong>argument(函数的形参申明) &gt; function声明 &gt; var声明 (也就之前提高的变量提升Hoisting)</strong></p>
<h5 id="第-2-2-部分：（执行）"><a href="#第-2-2-部分：（执行）" class="headerlink" title="第 2.2 部分：（执行）"></a>第 2.2 部分：（执行）</h5><ul>
<li>先执行<code>b=3</code>，再执行两个console.log，再执行：函数表达式申明，及执行。</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> JS执行顺序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS模块规范：AMD、UMD、CMD、commonJS、ES6 module]]></title>
      <url>/2017/08/22/JS%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83%EF%BC%9AAMD%E3%80%81UMD%E3%80%81CMD%E3%80%81commonJS%E3%80%81ES6%20module/</url>
      <content type="html"><![CDATA[<p>[TOC]</p>
<h2 id="commonJS"><a href="#commonJS" class="headerlink" title="commonJS"></a>commonJS</h2><ul>
<li>特点：</li>
</ul>
<blockquote>
<p>1、模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。<br>2、模块加载会阻塞接下来代码的执行，需要等到模块加载完成才能继续执行——同步加载。</p>
</blockquote>
<ul>
<li>环境：服务器环境</li>
<li>应用：nodejs的模块规范是参照commonJS实现的。</li>
<li>语法：</li>
</ul>
<blockquote>
<p>1、导入：require(‘路径’)<br>2、导出：module.exports和exports</p>
</blockquote>
<ul>
<li><p>注意：module.exports和exports的的区别是exports只是对module.exports的一个引用，相当于Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行<code>var exports = module.exports;</code>这样的命令。</p>
</li>
<li><p>demo</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.js</span></div><div class="line"><span class="comment">// 相当于这里还有一行：var exports = module.exports;代码</span></div><div class="line">exports.a = <span class="string">'Hello world'</span>;  <span class="comment">// 相当于：module.exports.a = 'Hello world';</span></div><div class="line"></div><div class="line"><span class="comment">// b.js</span></div><div class="line"><span class="keyword">var</span> moduleA = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</div><div class="line"><span class="built_in">console</span>.log(moduleA.a);     <span class="comment">// 打印出hello world</span></div></pre></td></tr></table></figure>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><ul>
<li>特点：</li>
</ul>
<blockquote>
<p>1、异步加载<br>2、管理模块之间的依赖性，便于代码的编写和维护。</p>
</blockquote>
<ul>
<li>环境：浏览器环境</li>
<li>应用：requireJS是参照AMD规范实现的</li>
<li>语法：</li>
</ul>
<blockquote>
<p>1、导入：require([‘模块名称’], function (‘模块变量引用’){// 代码});<br>3、导出：define(function (){return ‘值’);</p>
</blockquote>
<ul>
<li>demo</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.js</span></div><div class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">　　<span class="keyword">return</span> &#123;</div><div class="line">　　　a:<span class="string">'hello world'</span></div><div class="line">　　&#125;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// b.js</span></div><div class="line"><span class="built_in">require</span>([<span class="string">'./a.js'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">moduleA</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(moduleA.a); <span class="comment">// 打印出：hello world</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><ul>
<li>特点</li>
</ul>
<blockquote>
<p>1、CMD是在AMD基础上改进的一种规范，和AMD不同在于对依赖模块的执行时机处理不同，CMD是就近依赖，而AMD是前置依赖。</p>
</blockquote>
<ul>
<li>环境：浏览器环境</li>
<li>应用：seajs是参照UMD规范实现的，requireJS的最新的几个版本也是部分参照了UMD规范的实现</li>
<li>语法：</li>
</ul>
<blockquote>
<p>1、导入：define(function(require, exports, module) {});<br>2、导出：define(function (){return ‘值’);</p>
</blockquote>
<ul>
<li>demo</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.js</span></div><div class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>)</span>&#123;</div><div class="line">　　exports.a = <span class="string">'hello world'</span>;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// b.js</span></div><div class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> moduleA = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</div><div class="line">    <span class="built_in">console</span>.log(moduleA.a); <span class="comment">// 打印出：hello world</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h2><ul>
<li>特点：</li>
</ul>
<blockquote>
<p>1、兼容AMD和commonJS规范的同时，还兼容全局引用的方式</p>
</blockquote>
<ul>
<li>环境：浏览器或服务器环境</li>
<li>应用：无</li>
<li>语法：</li>
</ul>
<blockquote>
<p>1、无导入导出规范，只有如下的一个常规写法：</p>
</blockquote>
<ul>
<li>常规写法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">(function (root, factory) &#123;</div><div class="line">    if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123;</div><div class="line">        //AMD</div><div class="line">        define([&apos;jquery&apos;], factory);</div><div class="line">    &#125; else if (typeof exports === &apos;object&apos;) &#123;</div><div class="line">        //Node, CommonJS之类的</div><div class="line">        module.exports = factory(require(&apos;jquery&apos;));</div><div class="line">    &#125; else &#123;</div><div class="line">        //浏览器全局变量(root 即 window)</div><div class="line">        root.returnExports = factory(root.jQuery);</div><div class="line">    &#125;</div><div class="line">&#125;(this, function ($) &#123;</div><div class="line">    //方法</div><div class="line">    function myFunc()&#123;&#125;;</div><div class="line">    //暴露公共方法</div><div class="line">    return myFunc;</div><div class="line">&#125;));</div></pre></td></tr></table></figure>
<h2 id="ES6-module"><a href="#ES6-module" class="headerlink" title="ES6 module"></a>ES6 module</h2><ul>
<li>特点：</li>
</ul>
<blockquote>
<p>1、按需加载（编译时加载）<br>2、import和export命令只能在模块的顶层，不能在代码块之中（如：if语句中）,import()语句可以在代码块中实现异步动态按需动态加载</p>
</blockquote>
<ul>
<li>环境：浏览器或服务器环境（以后可能支持）</li>
<li>应用：ES6的最新语法支持规范</li>
<li>语法：</li>
</ul>
<blockquote>
<p>1、导入：import {模块名A，模块名B…} from ‘模块路径’<br>2、导出：export和export default<br>3、import(‘模块路径’).then()方法</p>
</blockquote>
<ul>
<li>注意：export只支持对象形式导出，不支持值的导出，export default命令用于指定模块的默认输出，只支持值导出，但是只能指定一个，本质上它就是输出一个叫做default的变量或方法。</li>
<li>规范：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*错误的写法*/</span></div><div class="line"><span class="comment">// 写法一</span></div><div class="line"><span class="keyword">export</span> <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">// 写法二</span></div><div class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</div><div class="line"><span class="keyword">export</span> m;</div><div class="line"></div><div class="line"><span class="comment">// 写法三</span></div><div class="line"><span class="keyword">if</span> (x === <span class="number">2</span>) &#123;</div><div class="line">  <span class="keyword">import</span> MyModual <span class="keyword">from</span> <span class="string">'./myModual'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*正确的三种写法*/</span></div><div class="line"><span class="comment">// 写法一</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> m = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">// 写法二</span></div><div class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</div><div class="line"><span class="keyword">export</span> &#123;m&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 写法三</span></div><div class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</div><div class="line"><span class="keyword">export</span> &#123;n <span class="keyword">as</span> m&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 写法四</span></div><div class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> n;</div><div class="line"></div><div class="line"><span class="comment">// 写法五</span></div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">    <span class="keyword">import</span>(<span class="string">'./myModule.js'</span>)</div><div class="line">    .then(<span class="function">(<span class="params">&#123;export1, export2&#125;</span>) =&gt;</span> &#123;</div><div class="line">      <span class="comment">// ...·</span></div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 写法六</span></div><div class="line"><span class="built_in">Promise</span>.all([</div><div class="line">  <span class="keyword">import</span>(<span class="string">'./module1.js'</span>),</div><div class="line">  <span class="keyword">import</span>(<span class="string">'./module2.js'</span>),</div><div class="line">  <span class="keyword">import</span>(<span class="string">'./module3.js'</span>),</div><div class="line">])</div><div class="line">.then(<span class="function">(<span class="params">[module1, module2, module3]</span>) =&gt;</span> &#123;</div><div class="line">   ···</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> AMD - UMD - CMD - commonJS - ES6 module </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS继承比较中寻找最优的继承方式]]></title>
      <url>/2017/08/22/JS%E7%BB%A7%E6%89%BF%E6%AF%94%E8%BE%83%E4%B8%AD%E5%AF%BB%E6%89%BE%E6%9C%80%E4%BC%98%E7%9A%84%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<ul>
<li>继承主要满足两方面的要求：<ul>
<li>1、复用父构造函数中的代码</li>
<li>2、复用父原型中的代码</li>
</ul>
</li>
</ul>
<h2 id="继承方式1"><a href="#继承方式1" class="headerlink" title="继承方式1"></a>继承方式1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">age</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line">Child.prototype = <span class="keyword">new</span> Parent(<span class="string">'小明'</span>);</div><div class="line">Child.prototype.constructor = Child;</div><div class="line">Child.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.age;</div><div class="line">&#125;</div><div class="line"><span class="keyword">new</span> Child(<span class="number">14</span>)</div></pre></td></tr></table></figure>
<ul>
<li>结论：这种构造方式虽然满足了继承要求，但是存在两个问题<ul>
<li>1、如果name和age参数分开创建，这其实对于使用继承没有明显的好处，如果能都在Child构造函数中创建就更好一点。</li>
<li>2、因为子类是通过子类的prototype来接受父类的构造函数和父类prototype的，这样如果子类创建多个实例，而且同时修改他们的prototype就有可能互相影响。</li>
</ul>
</li>
</ul>
<h2 id="继承方式2"><a href="#继承方式2" class="headerlink" title="继承方式2"></a>继承方式2</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    Parent.call(<span class="keyword">this</span>, name);</div><div class="line">&#125;</div><div class="line">Child.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</div><div class="line">&#125;;</div><div class="line">Child.prototype.__proto__ = Parent.prototype;</div></pre></td></tr></table></figure>
<ul>
<li>结论：两方面都考虑了，而且也实现了再子类中实例化参数，多个实例间也不会互相影响，可是仍然存在两个问题：<ul>
<li>修改<strong>proto</strong>的性能耗损比较严重</li>
<li>兼容性也比较差</li>
</ul>
</li>
</ul>
<h2 id="继承方式3"><a href="#继承方式3" class="headerlink" title="继承方式3"></a>继承方式3</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    Parent.call(<span class="keyword">this</span>, name);</div><div class="line">&#125;</div><div class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype);  <span class="comment">// 通过创建一个新的对象去继承</span></div><div class="line">Child.prototype.constructor = Child;                <span class="comment">// 上面改变了constructor指向，这里最好改回来</span></div><div class="line">Child.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>结论：两方面都考虑了，而且也实现了再子类中实例化参数，多个实例间也不会互相影响，但是仍然存在一个问题：<ul>
<li>Object.create兼容性一般</li>
</ul>
</li>
</ul>
<h2 id="继承方式4（最优继承）"><a href="#继承方式4（最优继承）" class="headerlink" title="继承方式4（最优继承）"></a>继承方式4（最优继承）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.create !== <span class="string">"function"</span>) &#123;</div><div class="line">    <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">proto, propertiesObject</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> proto !== <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> proto !== <span class="string">'function'</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Object prototype may only be an Object: '</span> + proto);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (proto === <span class="literal">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> propertiesObject != <span class="string">'undefined'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"This browser's implementation of Object.create is a shim and doesn't support a second argument."</span>);</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">        F.prototype = proto;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;)();</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    Parent.call(<span class="keyword">this</span>, name);</div><div class="line">&#125;</div><div class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype);</div><div class="line">Child.prototype.constructor = Child;</div><div class="line">Child.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>结论：两方面都考虑了，而且也实现了再子类中实例化参数，多个实例间也不会互相影响，使用polyfill也解决了兼容性问题，所以这个是最优的继承方式</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 继承 - 原型链 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS隐式类型转换的十二条规则]]></title>
      <url>/2017/08/22/JS%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%8D%81%E4%BA%8C%E6%9D%A1%E8%A7%84%E5%88%99/</url>
      <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote>
<p>“The comparison x == y, where x and y are values, producestrue or false.”</p>
<p>相等运算符用于比较两个值，返回true或false。</p>
</blockquote>
<h2 id="算法细节"><a href="#算法细节" class="headerlink" title="算法细节"></a>算法细节</h2><blockquote>
<p>1）ReturnIfAbrupt(x).<br>2）ReturnIfAbrupt(y).<br>3）If Type(x) is the same as Type(y), thenReturn the result of performing Strict Equality Comparisonx === y.<br>4）If x is null and y is undefined, return true.<br>5）If x is undefined and y is null, return true.<br>6）If Type(x) is Number and Type(y) is String,return the result of the comparison x == ToNumber(y).<br>7）If Type(x) is String and Type(y) is Number,return the result of the comparison ToNumber(x) == y.<br>8）If Type(x) is Boolean, return the result of the comparisonToNumber(x) == y.<br>9）If Type(y) is Boolean, return the result of the comparison x == ToNumber(y).<br>10）If Type(x) is either String, Number, or Symbol and Type(y)is Object, thenreturn the result of the comparison x == ToPrimitive(y).<br>11）If Type(x) is Object and Type(y) is either String, Number, or Symbol, thenreturn the result of the comparison ToPrimitive(x) == y.<br>12）Return false.</p>
<p>1）如果x不是正常值（比如抛出一个错误），中断执行。<br>2）如果y不是正常值，中断执行。<br>3）如果Type(x)与Type(y)相同，执行严格相等运算x === y。<br>4）如果x是null，y是undefined，返回true。<br>5）如果x是undefined，y是null，返回true。<br>6）如果Type(x)是数值，Type(y)是字符串，返回x == ToNumber(y)的结果。<br>7）如果Type(x)是字符串，Type(y)是数值，返回ToNumber(x) == y的结果。<br>8）如果Type(x)是布尔值，返回ToNumber(x) == y的结果。<br>9）如果Type(y)是布尔值，返回x == ToNumber(y)的结果。<br>10）如果Type(x)是字符串或数值或Symbol值，Type(y)是对象，返回x == ToPrimitive(y)的结果。<br>11）如果Type(x)是对象，Type(y)是字符串或数值或Symbol值，返回ToPrimitive(x) == y的结果。<br>12）返回false</p>
</blockquote>
<ul>
<li>注意：<strong>ToPrimitive(y)</strong> 的判断返回规则是，如果 y 不等于 Date 类型的对象，那么先比较y.valueOf() 的值，如果是基本类型返回，不是的话再比较 y.toString() 的值。</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 隐式转换 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[名词汇总JS解决sticky的兼容性问题]]></title>
      <url>/2017/08/22/JS%E8%A7%A3%E5%86%B3sticky%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>在项目中有用到sticky的布局，可是由于兼容性问题，在安卓端没有很好的兼容，所以为了彻底解决这个问题只能写一个组件来解决这个麻烦的问题，这里为什么是组件而不是指令是因为，是有原因的，下面会讲到。</p>
<p>##position:sticky的兼容性以及作用<br>Caniuse上显示sticky的兼容性如下：<br><img src="https://sfault-image.b0.upaiyun.com/209/641/2096419143-59e59f03578b1_articlex" alt=""><br>Sticky的作用相当于relative和fixed的结合体，当修饰的目标节点再屏幕中时表现为relative，当要超出的时候是fixed的形式展现，因为这个特性，我们就可以来实现一个sticky的模拟效果。</p>
<p>##sticky组件实现</p>
<p>####template部分<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"sticky"</span> <span class="attr">:style</span>=<span class="string">"getPosition"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"sticky-warp"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>代码解读</strong>：这里我使用了组件来实现，而不用指令来实现的原因是：指令虽然是无侵入性的，更方便使用，可是有一个弊端就是当修饰的节点fixed的时候会脱离文档流，会改变滚动的条的高度，如果仅仅是配合原生滚动条来实现是没问题的（当然这也会存在滚动过快的问题），可是由于是配合自定义滚动所以，采取这种折中的方式来实现。最外层是一个sticky层，判断浏览器是否支持sticky，不支持就使用relative来代替，这样也就不会改变浏览器高度的情况了，然后动态改变stick-warp层的postion来实现效果。</p>
<p>####css部分<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span> <span class="attr">lang</span>=<span class="string">"less"</span> <span class="attr">rel</span>=<span class="string">"stylesheet/less"</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined">    .sticky &#123;</span></div><div class="line"><span class="undefined">        width: 100%;</span></div><div class="line"><span class="undefined">        .sticky-warp &#123;</span></div><div class="line"><span class="undefined">            width: 100%;</span></div><div class="line"><span class="undefined">            background: inherit;</span></div><div class="line"><span class="undefined">            will-change: change;</span></div><div class="line"><span class="undefined">            height: inherit;</span></div><div class="line"><span class="undefined">            top: inherit;</span></div><div class="line"><span class="undefined">        &#125;</span></div><div class="line"><span class="undefined">    &#125;</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>代码解读</strong>：这里的warp层的背景色设置和sticky一致，这样过渡不会太生硬，高度和top都根据用户对外层sticky的自定义来实现，这样这部分简单用css就可以完成了。</p>
<p>####JS部分</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/babel"</span>&gt;</div><div class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">        data () &#123;</div><div class="line">            <span class="keyword">return</span> &#123;&#125;</div><div class="line">        &#125;,</div><div class="line">        computed: &#123;</div><div class="line">            getPosition()&#123;</div><div class="line">                <span class="keyword">var</span> position = <span class="keyword">this</span>.cssSupport(<span class="string">'position'</span>, <span class="string">'sticky'</span>) ? <span class="string">'sticky'</span> : <span class="string">'relative'</span>;</div><div class="line">                <span class="keyword">return</span> <span class="string">'position:'</span> + position;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        props: &#123;&#125;,</div><div class="line">        beforeMount () &#123;</div><div class="line">        &#125;,</div><div class="line">        mounted()&#123;</div><div class="line">            <span class="keyword">this</span>.init();</div><div class="line">        &#125;,</div><div class="line">        deactivated()&#123;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.cssSupport(<span class="string">'position'</span>, <span class="string">'sticky'</span>)) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">/*复位*/</span></div><div class="line">            <span class="keyword">var</span> elWarp = <span class="keyword">this</span>.$el.querySelector(<span class="string">'.sticky-warp'</span>);</div><div class="line">            elWarp.position = <span class="string">'absolute'</span>;</div><div class="line">        &#125;,</div><div class="line">        methods: &#123;</div><div class="line">            init()&#123;</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.cssSupport(<span class="string">'position'</span>, <span class="string">'sticky'</span>)) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">var</span> el = <span class="keyword">this</span>.$el, target = <span class="keyword">this</span>.$el.parentNode,</div><div class="line">                        elWarp = <span class="keyword">this</span>.$el.querySelector(<span class="string">'.sticky-warp'</span>),</div><div class="line">                        top = <span class="keyword">this</span>.getNumberValue(<span class="built_in">document</span>.defaultView.getComputedStyle(el).top);</div><div class="line">                <span class="keyword">this</span>.addScrollListen(target, (event)=&gt; &#123;</div><div class="line">                    <span class="keyword">if</span> (el.getBoundingClientRect().top &lt;= top) &#123;</div><div class="line">                        elWarp.style.position = <span class="string">'fixed'</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (el.getBoundingClientRect().top &gt;= <span class="number">0</span> &amp;&amp; elWarp.style.position != <span class="string">'absolute'</span>) &#123;</div><div class="line">                        elWarp.style.position = <span class="string">'absolute'</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;)</div><div class="line">            &#125;,</div><div class="line">            cssSupport: <span class="function"><span class="keyword">function</span> (<span class="params">attr, value</span>) </span>&#123;</div><div class="line">                <span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line">                <span class="keyword">if</span> (attr <span class="keyword">in</span> element.style) &#123;</div><div class="line">                    element.style[attr] = value;</div><div class="line">                    <span class="keyword">return</span> element.style[attr] === value;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">            getNumberValue(pxValue)&#123;</div><div class="line">                <span class="keyword">var</span> value = <span class="built_in">String</span>(pxValue).match(<span class="regexp">/^\-?\+?[0-9]+/g</span>);</div><div class="line">                <span class="keyword">return</span> value ? <span class="built_in">Number</span>(value) : <span class="literal">undefined</span>;</div><div class="line">            &#125;,</div><div class="line">            addScrollListen(target, cb)&#123;</div><div class="line">                target.addEventListener(<span class="string">'y-scroll'</span>, (event)=&gt; &#123;</div><div class="line">                    cb &amp;&amp; cb(event);</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p><strong>代码解读</strong>：这里面主要先用cssSupport来判断一下浏览器的支持情况，然后通过多自定义滚动y-scroll事件的监听，监听top值的改变来实现sticky-warp层的fixed和absolute的转换。大概原理的思路及实现过程就是上面这样，对于自定义的滚动的github地址：<a href="https://github.com/yejiaming/scroll" target="_blank" rel="external">https://github.com/yejiaming/scroll</a>，sticky组件以及原生滚动下的指令参考的实现的github地址如下：<a href="https://github.com/yejiaming/sticky" target="_blank" rel="external">https://github.com/yejiaming/sticky</a></p>
]]></content>
      
        
        <tags>
            
            <tag> sticky </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用contenteditable+div模拟textarea文本域实现高度自适应]]></title>
      <url>/2017/08/22/%E4%BD%BF%E7%94%A8contenteditable+div%E6%A8%A1%E6%8B%9Ftextarea%E6%96%87%E6%9C%AC%E5%9F%9F%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94/</url>
      <content type="html"><![CDATA[<p>开发过程中由于需要在发送消息的时候需要有一个可以高度自适应的文本域，一开始是使用textarea并搭配auto-size插件来做到textarea的高度自适应，后来因为遇到一些问题，而且也多加了依赖缺乏可定制，所以决定使用contenteditable来实现。</p>
<h2 id="contenteditable介绍"><a href="#contenteditable介绍" class="headerlink" title="contenteditable介绍"></a>contenteditable介绍</h2><p><strong>contenteditable</strong>属性规定元素内容是否可编辑，是H5新增的属性，支持情况相当好，基本上所有的浏览器都兼容。</p>
<p><strong>语法：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">element</span> <span class="attr">contenteditable</span>=<span class="string">"true|false"</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="实现主要代码如下"><a href="#实现主要代码如下" class="headerlink" title="实现主要代码如下"></a>实现主要代码如下</h2><p>代码实现是基于vue来实现的。<br><strong>html部分：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"textarea"</span> <span class="attr">contenteditable</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong>CSS部分</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;style scoped lang="less" rel="stylesheet/less"&gt;</div><div class="line">    <span class="selector-class">.textarea</span> &#123;</div><div class="line">        <span class="attribute">box-sizing</span>: border-box;</div><div class="line">        <span class="attribute">min-height</span>: <span class="number">136px</span>;</div><div class="line">        <span class="attribute">max-height</span>: <span class="number">300px</span>;</div><div class="line">        <span class="attribute">margin-left</span>: auto;</div><div class="line">        <span class="attribute">margin-right</span>: auto;</div><div class="line">        <span class="attribute">padding</span>: <span class="number">3px</span>;</div><div class="line">        <span class="attribute">outline</span>: <span class="number">0</span>;</div><div class="line">        <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#a0b3d6</span>;</div><div class="line">        <span class="attribute">font-size</span>: <span class="number">12px</span>;</div><div class="line">        <span class="attribute">word-wrap</span>: break-word;</div><div class="line">        <span class="attribute">overflow-x</span>: hidden;</div><div class="line">        <span class="attribute">overflow-y</span>: auto;</div><div class="line">        <span class="attribute">_overflow-y</span>: visible;</div><div class="line">        -webkit-user-modify: read-write-plaintext-only; // 只是编辑text文本，只能解决webkit内核里面问题，手机端适用</div><div class="line">        -webkit-user-select: text; // 解决IOS部分手机不支持contenteditable=true属性问题</div><div class="line">        <span class="selector-tag">p</span> &#123;</div><div class="line">            <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure>
<p><strong>代码解读：</strong></p>
<ul>
<li>设置-webkit-user-modify属性，是为了在剪切复制的时候会把剪切的内容的格式也一并带过来，由于我们是仿写textarea，是不支持富文本的，所以需要需要将内容格式化成文本格式，而该属性在webkit内核下就可以达到我们的目的。</li>
<li>设置-webkit-user-select属性，是为了解决在测试过程中出现部分IOS手机不支持contenteditable属性的问题。</li>
</ul>
<p><strong>JS部分：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/babel"</span>&gt;</div><div class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">        mounted() &#123;</div><div class="line">            <span class="keyword">this</span>.addInputEvent();</div><div class="line">            <span class="keyword">this</span>.addFocusEvent();</div><div class="line">            <span class="keyword">this</span>.addEventPaste(<span class="keyword">this</span>.$el);</div><div class="line">        &#125;,</div><div class="line">        methods: &#123;</div><div class="line">            <span class="comment">/**</span></div><div class="line"><span class="comment">             * 监听鼠标input事件</span></div><div class="line"><span class="comment">             */</span></div><div class="line">            addInputEvent()&#123;</div><div class="line">                <span class="keyword">this</span>.$el.addEventListener(<span class="string">'input'</span>, () =&gt; &#123;</div><div class="line">                    <span class="keyword">this</span>.$emit(<span class="string">'input'</span>, <span class="keyword">this</span>.getValue());</div><div class="line">                &#125;)</div><div class="line">            &#125;,</div><div class="line">            <span class="comment">/**</span></div><div class="line"><span class="comment">             * 监听鼠标获取焦点事件</span></div><div class="line"><span class="comment">             */</span></div><div class="line">            addFocusEvent()&#123;</div><div class="line">                <span class="keyword">this</span>.$el.addEventListener(<span class="string">'focus'</span>, () =&gt; &#123;</div><div class="line">                    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">                        <span class="comment">// 解决：如果ios手机使用的不是原生键盘（也可能不止IOS手机有这个问题），则会出现键盘挡住输入框问题，当bottom=0的情况，使用这个属性就可以滚动屏幕中央</span></div><div class="line">                        <span class="keyword">this</span>.$el.scrollIntoView(<span class="literal">true</span>);</div><div class="line">                    &#125;, <span class="number">300</span>);</div><div class="line">                    <span class="keyword">this</span>.$emit(<span class="string">'focus'</span>);</div><div class="line">                &#125;)</div><div class="line">            &#125;,</div><div class="line">            <span class="comment">/**</span></div><div class="line"><span class="comment">             * 追加</span></div><div class="line"><span class="comment">             * @param value</span></div><div class="line"><span class="comment">             * @param bool</span></div><div class="line"><span class="comment">             */</span></div><div class="line">            appendValue(value, bool) &#123;</div><div class="line">                <span class="keyword">this</span>.$el.innerText += value;</div><div class="line">                <span class="keyword">this</span>.$emit(<span class="string">'input'</span>, <span class="keyword">this</span>.getValue());</div><div class="line">            &#125;,</div><div class="line">            <span class="comment">/**</span></div><div class="line"><span class="comment">             * 监听复制事件，去除样式得到纯文本</span></div><div class="line"><span class="comment">             */</span></div><div class="line">            addEventPaste: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">                <span class="comment">// 干掉IE http之类地址自动加链接</span></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="built_in">document</span>.execCommand(<span class="string">"AutoUrlDetect"</span>, <span class="literal">false</span>, <span class="literal">false</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 监听复制paste事件，目的是为了让-webkit-user-modify属性兼容IE8，毕竟该属性在IE兼容性不好</span></div><div class="line">                el.addEventListener(<span class="string">'paste'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">                    e.preventDefault();</div><div class="line">                    <span class="keyword">var</span> text = <span class="literal">null</span>;</div><div class="line">                    <span class="keyword">if</span> (<span class="built_in">window</span>.clipboardData &amp;&amp; clipboardData.setData) &#123;</div><div class="line">                        <span class="comment">// IE</span></div><div class="line">                        text = <span class="built_in">window</span>.clipboardData.getData(<span class="string">'text'</span>);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        text = (e.originalEvent || e).clipboardData.getData(<span class="string">'text/plain'</span>) || prompt(<span class="string">'在这里输入文本'</span>);</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 这里的目的是为了将鼠标的光标移动到复制之后文本的末尾的末尾</span></div><div class="line">                    <span class="keyword">if</span> (<span class="built_in">document</span>.body.createTextRange) &#123;</div><div class="line">                        <span class="keyword">if</span> (<span class="built_in">document</span>.selection) &#123;</div><div class="line">                            textRange = <span class="built_in">document</span>.selection.createRange();</div><div class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.getSelection) &#123;</div><div class="line">                            sel = <span class="built_in">window</span>.getSelection();</div><div class="line">                            <span class="keyword">var</span> range = sel.getRangeAt(<span class="number">0</span>);</div><div class="line">                            <span class="comment">// 创建临时元素，使得TextRange可以移动到正确的位置</span></div><div class="line">                            <span class="keyword">var</span> tempEl = <span class="built_in">document</span>.createElement(<span class="string">"span"</span>);</div><div class="line">                            tempEl.innerHTML = <span class="string">"&amp;#FEFF;"</span>;</div><div class="line">                            range.deleteContents();</div><div class="line">                            range.insertNode(tempEl);</div><div class="line">                            textRange = <span class="built_in">document</span>.body.createTextRange();</div><div class="line">                            textRange.moveToElementText(tempEl);</div><div class="line">                            tempEl.parentNode.removeChild(tempEl);</div><div class="line">                        &#125;</div><div class="line">                        textRange.text = text;</div><div class="line">                        textRange.collapse(<span class="literal">false</span>);</div><div class="line">                        textRange.select();</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">// Chrome之类浏览器</span></div><div class="line">                        <span class="built_in">document</span>.execCommand(<span class="string">"insertText"</span>, <span class="literal">false</span>, text);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;,</div><div class="line">            <span class="comment">/**</span></div><div class="line"><span class="comment">             * 替换</span></div><div class="line"><span class="comment">             * @param value</span></div><div class="line"><span class="comment">             */</span></div><div class="line">            setValue(value) &#123;</div><div class="line">                <span class="keyword">this</span>.$el.innerText = value;</div><div class="line">                <span class="keyword">this</span>.$emit(<span class="string">'input'</span>, <span class="keyword">this</span>.getValue());</div><div class="line">            &#125;,</div><div class="line">            <span class="comment">/**</span></div><div class="line"><span class="comment">             * 获取值</span></div><div class="line"><span class="comment">             * @returns &#123;*&#125;</span></div><div class="line"><span class="comment">             */</span></div><div class="line">            getValue() &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.getHtmlToText();</div><div class="line">            &#125;,</div><div class="line">            <span class="comment">/**</span></div><div class="line"><span class="comment">             * 获取HTML转换之后的文本（去除div标签，替换&lt;br/&gt;为换行）</span></div><div class="line"><span class="comment">             * @returns &#123;string&#125;</span></div><div class="line"><span class="comment">             */</span></div><div class="line">            getHtmlToText() &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.replaceToBreak(<span class="keyword">this</span>.getHtml());</div><div class="line">            &#125;,</div><div class="line">            <span class="comment">/**</span></div><div class="line"><span class="comment">             * 获取HTML</span></div><div class="line"><span class="comment">             */</span></div><div class="line">            getHtml() &#123;</div><div class="line">                <span class="keyword">return</span> <span class="built_in">document</span>.querySelector(<span class="string">'.textarea'</span>).innerHTML</div><div class="line">            &#125;,</div><div class="line">            <span class="comment">/**</span></div><div class="line"><span class="comment">             * 替换DIV到换行符</span></div><div class="line"><span class="comment">             * @returns &#123;string&#125;</span></div><div class="line"><span class="comment">             */</span></div><div class="line">            replaceToBreak(html) &#123;</div><div class="line">                html = <span class="built_in">String</span>(html).replace(<span class="regexp">/&lt;\/div&gt;/gi</span>, <span class="string">''</span>);</div><div class="line">                html = html.replace(<span class="regexp">/&lt;div&gt;(&lt;br&gt;)?(&lt;br\/&gt;)?/gi</span>, <span class="string">'\n'</span>);</div><div class="line">                html = html.replace(<span class="regexp">/&lt;br&gt;|&lt;br\/&gt;/gi</span>, <span class="string">'\n'</span>);</div><div class="line">                <span class="keyword">return</span> html;</div><div class="line">            &#125;,</div><div class="line">            <span class="comment">/**</span></div><div class="line"><span class="comment">             * 获取纯text文本</span></div><div class="line"><span class="comment">             * @returns &#123;string&#125;</span></div><div class="line"><span class="comment">             */</span></div><div class="line">            getText()&#123;</div><div class="line">                <span class="keyword">if</span> (<span class="built_in">window</span>.navigator.appName.indexOf(<span class="string">"Explorer"</span>) &gt; <span class="number">-1</span>)</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.$el.innerText;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.$el.textContent;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">    &#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p><strong>代码解读：</strong></p>
<ul>
<li>其中<strong>addEventPaste</strong>方法是为了解决非webkit内核对于<strong>-webkit-user-select</strong>属性支持不好的问题。里面主要是监听黏贴事件然后或者剪切板的文本内容然后再阻止黏贴事件，并将文本内容追加到光标中，并将光标移动到相应的位置。</li>
<li>其中<strong>replaceToBreak</strong>方法是为了解决在textarea中换行的问题，在该伪textarea中换行是会单独将换行内容放到新的DIV中的，所以，当我们需要对该内容进行格式化处理才行。</li>
<li><strong>this.$el.scrollIntoView</strong>的作用是为了当使用者将我们的输入框是使用绝对定位放在页面底部的时候而被虚拟键盘遮挡的问题。</li>
</ul>
<h2 id="issue"><a href="#issue" class="headerlink" title="issue"></a>issue</h2><ul>
<li>使用该组件注意一个问题就是不要在可视化区域的节点上使用-<strong>webkit-user-select: none</strong>样式，否则会出现当鼠标焦点小时光标和小水滴无法消失的情况</li>
</ul>
<h2 id="github地址"><a href="#github地址" class="headerlink" title="github地址"></a>github地址</h2><p><a href="https://github.com/yejiaming/textarea/tree/master" target="_blank" rel="external">github项目地址</a></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.zhangxinxu.com/wordpress/2010/12/div-textarea-height-auto/" target="_blank" rel="external">div模拟textarea文本域轻松实现高度自适应</a><br><a href="http://www.zhangxinxu.com/wordpress/2016/01/contenteditable-plaintext-only/" target="_blank" rel="external">如何让contenteditable元素只能输入纯文本</a></p>
]]></content>
      
        
        <tags>
            
            <tag> contenteditable </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于top、left结合translate实现居中的原理探讨]]></title>
      <url>/2017/08/22/%E5%85%B3%E4%BA%8Etop%E3%80%81left%E7%BB%93%E5%90%88translate%E5%AE%9E%E7%8E%B0%E5%B1%85%E4%B8%AD%E7%9A%84%E5%8E%9F%E7%90%86%E6%8E%A2%E8%AE%A8/</url>
      <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><ul>
<li>在居中对齐的方法中常用的一种方法之一，就是使用绝对定位结合 translate、top、left实现居中，探讨原理之前先来看一下实现代码和实现效果：</li>
</ul>
<p></p><p data-height="300" data-theme-id="32624" data-slug-hash="paZEVz" data-default-tab="css,result" data-user="yejiaming" data-embed-version="2" data-pen-title="paZEVz" class="codepen">See the Pen <a href="https://codepen.io/yejiaming/pen/paZEVz/" target="_blank" rel="external">paZEVz</a> by yeArvin (<a href="https://codepen.io/yejiaming" target="_blank" rel="external">@yejiaming</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<ul>
<li>上面的实现效果最主要的代码如下：</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.out</span> &#123;</div><div class="line">  <span class="attribute">position</span>: relative;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.in</span> &#123;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</div><div class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</div><div class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>解读：</em>由此可见主要是由top、left的百分比和translate百分比实现的，那我们接下来就有必要讲一下两者百分比的原理了：</p>
<h3 id="top、left的百分比的原理"><a href="#top、left的百分比的原理" class="headerlink" title="top、left的百分比的原理"></a>top、left的百分比的原理</h3><ul>
<li>从上述的代码和效果中可以看出，居中对齐的实现是依靠了<strong>top/left</strong>的的百分比来实现的，而且还是<strong>正</strong>的百分比，下面我们先给出其百分比和位置的公式：</li>
</ul>
<blockquote>
<p>X（内X轴偏移量） = width（外） <em> left百分比（内）<br>  Y（内Y轴偏移量） = height（外） </em> top百分比（内）</p>
</blockquote>
<ul>
<li>演示：</li>
</ul>
<p></p><p data-height="300" data-theme-id="32624" data-slug-hash="WMKxVK" data-default-tab="css,result" data-user="yejiaming" data-embed-version="2" data-pen-title="WMKxVK" class="codepen">See the Pen <a href="https://codepen.io/yejiaming/pen/WMKxVK/" target="_blank" rel="external">WMKxVK</a> by yeArvin (<a href="https://codepen.io/yejiaming" target="_blank" rel="external">@yejiaming</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h3 id="translate的百分比的原理"><a href="#translate的百分比的原理" class="headerlink" title="translate的百分比的原理"></a>translate的百分比的原理</h3><ul>
<li>从上述的代码和效果中可以看出，居中对齐的实现是还依靠了<strong>translate</strong>，而且还是负的百分比，下面我们先给出它百分比和位置的公式：</li>
</ul>
<blockquote>
<p>X（内X轴偏移量） = width（内） <em> translateX百分比（内）<br>  Y（内Y轴偏移量） = height（内） </em> translateY百分比（内）</p>
</blockquote>
<ul>
<li>演示</li>
</ul>
<p></p><p data-height="300" data-theme-id="32624" data-slug-hash="XZBKeO" data-default-tab="css,result" data-user="yejiaming" data-embed-version="2" data-pen-title="XZBKeO" class="codepen">See the Pen <a href="https://codepen.io/yejiaming/pen/XZBKeO/" target="_blank" rel="external">XZBKeO</a> by yeArvin (<a href="https://codepen.io/yejiaming" target="_blank" rel="external">@yejiaming</a>) on <a href="https://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上述的原理解读中可以看出最终的位置的计算公式是：</p>
<blockquote>
<p>X（内X轴偏移量） = width（外） <em> left百分比（内） + width（内） </em> translateX百分比（内）<br>  Y（内Y轴偏移量） = height（外） <em> top百分比（内） + height（内） </em> translateY百分比（内）</p>
</blockquote>
<p><strong>即：</strong></p>
<blockquote>
<p>X（内X轴偏移量） = 300 <em> 50% + 100 </em> -50% = 100<br>Y（内X轴偏移量） = 300 <em> 50% + 100 </em> -50% = 100</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> 垂直居中 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[前端性能优化]]></title>
      <url>/2017/08/22/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul>
<li>1）减少HTTP请求，合并压缩JS和CSS文件；</li>
<li>2）避免重定向；</li>
</ul>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><ul>
<li>1）合理使用域名收敛和域名扩散，在减少DNS解析次数的同时，增大浏览器对同域名的连接数；</li>
<li>2）在首页合理使用 DNS 预解析；</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"x-dns-prefetch-control"</span> <span class="attr">content</span>=<span class="string">"on"</span>&gt;</span></div><div class="line"><span class="comment">&lt;!--以下就是可以预解析的域名了--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"//www.itechzero.com"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"//api.share.baidu.com"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"//bdimg.share.baidu.com"</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><ul>
<li>1）使用CDN；</li>
<li>2）添加合理的Expires或Cache-Control响应头，配置 ETag；</li>
<li>3）开启gzip压缩；</li>
</ul>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><ul>
<li>1）避免空 src，因为会影响 DOMContentLoaded 和 Loaded；</li>
<li>2）尽量不要使用 iframe；</li>
<li>3）按需加载和预加载 JS 和 CSS；</li>
</ul>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ul>
<li>1）CSS精灵；</li>
<li>2）使用 link 代替 @import；</li>
<li>3）不适用 CSS 表达式；</li>
<li>4）将样式表放到页面顶部去加载；</li>
<li>5）合理使用媒体查询按需加载CSS；</li>
</ul>
<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><ul>
<li>1）将脚本放到页面底部加载；</li>
<li>2）如果是首页的关键性的脚本，建议内联，其他的建议外部引用的方式；</li>
<li>3）按需加载需要的脚本；</li>
<li>5）使用事件代理，减少事件监听；</li>
<li>6）减少 DOM 访问，操作样式尽量针对 class 不要直接改变 style，如果一次性 DOM 操作节点过多的话建议使用 DocumentFragment 加快DOM渲染速度；</li>
<li>7）动画效果的实现尽量使用 transform 属性代替其他的属性，因为 transform 不会触发重排操作；</li>
</ul>
<h2 id="img"><a href="#img" class="headerlink" title="img"></a>img</h2><ul>
<li>1）不要拉伸图片，保持 1：1 的比例就可以；</li>
<li>2）保证 favicon.ico 小并且可缓存；</li>
<li>3）进行图片压缩；</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 性能 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSSOM视图模式(CSSOM View Module)]]></title>
      <url>/2017/08/22/CSSOM%E8%A7%86%E5%9B%BE%E6%A8%A1%E5%BC%8F(CSSOM%20View%20Module)/</url>
      <content type="html"><![CDATA[<p>[TOC]</p>
<h2 id="Window视图属性"><a href="#Window视图属性" class="headerlink" title="Window视图属性"></a>Window视图属性</h2><h3 id="innerWidth-和-innerHeight"><a href="#innerWidth-和-innerHeight" class="headerlink" title="innerWidth 和 innerHeight"></a><code>innerWidth</code> 和 <code>innerHeight</code></h3><ul>
<li>这两个属性 表示获取window窗体的内部宽度和高度，不包括用户界面元素，比如任务栏、窗框等。</li>
<li>兼容性：<img src="media/15105440971653/15121111242239.jpg" alt=""></li>
</ul>
<h3 id="outerWidth和outerHeight"><a href="#outerWidth和outerHeight" class="headerlink" title="outerWidth和outerHeight"></a><code>outerWidth</code>和<code>outerHeight</code></h3><ul>
<li>outerWidth/outerHeight表示整个浏览器窗体的大小，包括任务栏、窗框等。</li>
<li>兼容性：<img src="media/15105440971653/15121112115549.jpg" alt=""></li>
</ul>
<h3 id="pageXOffset和pageYOffset"><a href="#pageXOffset和pageYOffset" class="headerlink" title="pageXOffset和pageYOffset"></a><code>pageXOffset</code>和<code>pageYOffset</code></h3><ul>
<li>表示整个页面滚动条卷去部分的滚动像素值（水平方向的和垂直方向的），和scrollTop作用是一样的，但不同的是他们的属性是只读的。</li>
<li>兼容性：<img src="media/15105440971653/15121112689246.jpg" alt=""></li>
</ul>
<h3 id="screenX-和-screenY"><a href="#screenX-和-screenY" class="headerlink" title="screenX 和 screenY"></a><code>screenX</code> 和 <code>screenY</code></h3><ul>
<li>浏览器窗口在显示器中的位置，screenX表示水平位置，screenY表示垂直位置。该属性兼容性如下表：</li>
<li>兼容性：<img src="media/15105440971653/15121122362235.jpg" alt=""></li>
</ul>
<h2 id="Screen视图属性"><a href="#Screen视图属性" class="headerlink" title="Screen视图属性"></a>Screen视图属性</h2><h3 id="availWidth和availHeight"><a href="#availWidth和availHeight" class="headerlink" title="availWidth和availHeight"></a><code>availWidth</code>和<code>availHeight</code></h3><ul>
<li>表示显示器可用宽高，不包括任务栏、窗框等。</li>
<li>兼容性：<img src="media/15105440971653/15121123533818.jpg" alt=""></li>
</ul>
<h3 id="colorDepth"><a href="#colorDepth" class="headerlink" title="colorDepth"></a><code>colorDepth</code></h3><ul>
<li>表示显示器的颜色深度。</li>
<li><p>兼容性：<br><img src="media/15105440971653/15121124668943.jpg" alt=""></p>
</li>
<li><p>应用</p>
</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在8比特屏显示交替的背景颜色：</span></div><div class="line"><span class="keyword">if</span> (screen.colorDepth&lt;=<span class="number">8</span>)</div><div class="line">    <span class="comment">//为8位屏幕的简单的蓝色背景色</span></div><div class="line">    <span class="built_in">document</span>.body.style.background=<span class="string">"#0000FF"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">    <span class="comment">//为现代屏幕的华丽的蓝色背景色</span></div><div class="line">    <span class="built_in">document</span>.body.style.background=<span class="string">"#87CEFA"</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="pixelDepth"><a href="#pixelDepth" class="headerlink" title="pixelDepth"></a><code>pixelDepth</code></h3><ul>
<li>该属性基本上与colorDepth一样。</li>
<li>兼容性：<img src="media/15105440971653/15121128310463.jpg" alt=""></li>
</ul>
<h3 id="width和height"><a href="#width和height" class="headerlink" title="width和height"></a><code>width</code>和<code>height</code></h3><ul>
<li>表示显示器屏幕的宽高，包括任务栏、窗框等。</li>
<li>兼容性：<img src="media/15105440971653/15121128869970.jpg" alt=""></li>
</ul>
<h2 id="文档视图-DocumentView-和元素视图-ElementView-方法"><a href="#文档视图-DocumentView-和元素视图-ElementView-方法" class="headerlink" title="文档视图(DocumentView)和元素视图(ElementView)方法"></a>文档视图(<code>DocumentView</code>)和元素视图(<code>ElementView</code>)方法</h2><h3 id="elementFromPoint"><a href="#elementFromPoint" class="headerlink" title="elementFromPoint()"></a><code>elementFromPoint()</code></h3><ul>
<li>返回给定坐标处所在的元素。</li>
<li>兼容性：<img src="media/15105440971653/15121131566318.jpg" alt=""></li>
</ul>
<h3 id="getBoundingClientRect"><a href="#getBoundingClientRect" class="headerlink" title="getBoundingClientRect()"></a><code>getBoundingClientRect()</code></h3><ul>
<li>得到矩形元素的界线，返回的是一个对象，包含 top, left, right, 和 bottom四个属性值，大小都是相对于文档视图左上角计算而来。返回内容类似于：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    top: <span class="number">143</span>,</div><div class="line">    right: <span class="number">1196</span>,</div><div class="line">    bottom: <span class="number">164</span>,</div><div class="line">    left: <span class="number">889</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>兼容性：<img src="media/15105440971653/15121133163097.jpg" alt=""></li>
</ul>
<h3 id="getClientRects"><a href="#getClientRects" class="headerlink" title="getClientRects()"></a><code>getClientRects()</code></h3><ul>
<li>返回元素的数个矩形区域，返回的结果是个对象列表，具有数组特性。这里的矩形选区只针对inline box，因此，只针对a, span, em这类标签元素。</li>
<li><a href="http://www.zhangxinxu.com/study/201109/get-client-rects.html" target="_blank" rel="external">demo</a></li>
<li>兼容性：<img src="media/15105440971653/15121134341115.jpg" alt=""></li>
<li>应用：可以计算从服务器返回的数据会在不同的浏览器或者手机上(IE6/IE7除外)内容占的行数。</li>
</ul>
<h3 id="scrollIntoView"><a href="#scrollIntoView" class="headerlink" title="scrollIntoView()"></a><code>scrollIntoView()</code></h3><ul>
<li>让元素滚动到可视区域（不属于草案方法）。</li>
<li>兼容性：<img src="media/15105440971653/15121140405192.jpg" alt=""></li>
<li>应用：实现元素的锚点跳转功能的另外一条途径。</li>
</ul>
<h2 id="元素视图属性"><a href="#元素视图属性" class="headerlink" title="元素视图属性"></a>元素视图属性</h2><h3 id="clientLeft和clientTop"><a href="#clientLeft和clientTop" class="headerlink" title="clientLeft和clientTop"></a><code>clientLeft</code>和<code>clientTop</code></h3><ul>
<li>表示内容区域（不包括padding）的左上角相对于整个元素左上角的位置（包括边框，或者说近似等于边框border的值）。</li>
<li>兼容性：<img src="media/15105440971653/15121144544400.jpg" alt=""></li>
</ul>
<h3 id="clientWidth和clientHeight"><a href="#clientWidth和clientHeight" class="headerlink" title="clientWidth和clientHeight"></a><code>clientWidth</code>和<code>clientHeight</code></h3><ul>
<li>表示内容区域的高度和宽度，包括padding大小，但是不包括边框和滚动条。</li>
<li>兼容性：<img src="media/15105440971653/15121147949919.jpg" alt=""></li>
</ul>
<h3 id="offsetWidth和offsetHeight"><a href="#offsetWidth和offsetHeight" class="headerlink" title="offsetWidth和offsetHeight"></a><code>offsetWidth</code>和<code>offsetHeight</code></h3><ul>
<li>表示内容区域的高度和宽度，包括padding大小，包括边框。</li>
<li>兼容性：<img src="media/15105440971653/15121150524848.jpg" alt=""></li>
</ul>
<h3 id="offsetLeft和offsetTop"><a href="#offsetLeft和offsetTop" class="headerlink" title="offsetLeft和offsetTop"></a><code>offsetLeft</code>和<code>offsetTop</code></h3><ul>
<li>表示相对于最近的祖先定位元素（CSS position 属性被设置为 relative、absolute 或 fixed 的元素）的左右偏移值。</li>
<li>兼容性：<img src="media/15105440971653/15121148494839.jpg" alt=""></li>
</ul>
<h3 id="offsetParent"><a href="#offsetParent" class="headerlink" title="offsetParent"></a><code>offsetParent</code></h3><ul>
<li>第一个祖定位元素（即用来计算上面的<code>offsetLeft</code>和<code>offsetTop</code>的元素）。</li>
<li>兼容性：<img src="media/15105440971653/15121149242845.jpg" alt=""></li>
<li>另外，在IE和Opera浏览器下，<code>position: fixed</code>的元素没有<code>offsetParent</code>，<code>body</code>元素为定位元素的终极元素，所以其上头就没有其他定位元素了。</li>
</ul>
<h3 id="scrollLeft和scrollTop"><a href="#scrollLeft和scrollTop" class="headerlink" title="scrollLeft和scrollTop"></a><code>scrollLeft</code>和<code>scrollTop</code></h3><ul>
<li>表示元素滚动的像素大小。可读可写。</li>
<li>兼容性：<img src="media/15105440971653/15121151866827.jpg" alt=""></li>
</ul>
<h3 id="scrollWidth和scrollHeight"><a href="#scrollWidth和scrollHeight" class="headerlink" title="scrollWidth和scrollHeight"></a><code>scrollWidth</code>和<code>scrollHeight</code></h3><ul>
<li>表示整个内容区域的宽高，包括隐藏的部分。如果元素没有隐藏的部分，则相关的值应该等用于<code>clientWidth</code>和<code>clientHeight</code>。当你向下滚动滚动条的时候，<code>scrollHeight</code>应该等用于<code>scrollTop</code> + <code>clientHeight</code>。</li>
<li>兼容性：<img src="media/15105440971653/15121152881814.jpg" alt=""></li>
</ul>
<h2 id="鼠标位置-Mouse-position"><a href="#鼠标位置-Mouse-position" class="headerlink" title="鼠标位置(Mouse position)"></a>鼠标位置(Mouse position)</h2><h3 id="clientX和clientY"><a href="#clientX和clientY" class="headerlink" title="clientX和clientY"></a><code>clientX</code>和<code>clientY</code></h3><ul>
<li>相对于window，为鼠标相对于window的偏移。在iphone上，这对值返回的位置就等同于下面要提到的<code>pageX/Y</code>。</li>
<li>兼容性：<img src="media/15105440971653/15121153792617.jpg" alt=""></li>
</ul>
<h3 id="offsetX-和-offsetY"><a href="#offsetX-和-offsetY" class="headerlink" title="offsetX 和 offsetY"></a><code>offsetX</code> 和 <code>offsetY</code></h3><ul>
<li>表示鼠标相对于当前被点击元素padding box的左上偏移值。</li>
<li>兼容性：<img src="media/15105440971653/15121154190075.jpg" alt=""></li>
<li>在IE7以及以下浏览器下，只有当当前目标元素为offsetParent是才计算坐标值，否则，它就会拿当前目标元素的offsetParent来计算。还有，当发现元素应用了position: relative后，IE会去寻找下一个offsetParent来计算offsetY，但又不是offsetX。</li>
</ul>
<h3 id="pageX-和-pageY"><a href="#pageX-和-pageY" class="headerlink" title="pageX 和 pageY"></a><code>pageX</code> 和 <code>pageY</code></h3><ul>
<li>为鼠标相对于document的坐标。</li>
<li>兼容性：<img src="media/15105440971653/15121154992359.jpg" alt=""></li>
</ul>
<h3 id="screenX-和-screenY-1"><a href="#screenX-和-screenY-1" class="headerlink" title="screenX 和 screenY"></a><code>screenX</code> 和 <code>screenY</code></h3><ul>
<li>鼠标相对于显示器屏幕的偏移坐标。</li>
<li>兼容性：<img src="media/15105440971653/15121155406803.jpg" alt=""></li>
</ul>
<h3 id="x-和-y"><a href="#x-和-y" class="headerlink" title="x 和 y"></a><code>x</code> 和 <code>y</code></h3><ul>
<li>相当于clientX/clientY。</li>
<li>兼容性：<img src="media/15105440971653/15121155893074.jpg" alt=""></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> CSSOM视图模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[echarts 问题记录和解决方案]]></title>
      <url>/2017/08/22/echarts%20%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<h2 id="如何设置-Y-轴两边同时存在刻度，并且允许不同"><a href="#如何设置-Y-轴两边同时存在刻度，并且允许不同" class="headerlink" title="如何设置 Y 轴两边同时存在刻度，并且允许不同"></a>如何设置 Y 轴两边同时存在刻度，并且允许不同</h2><ul>
<li><p>效果如下：<br><img src="media/15210132803835/15210134115793.jpg" alt=""></p>
</li>
<li><p>解决方法：设置给<strong>yAxis</strong>设置成数组，并设置两个，然后在<strong>series</strong>中设置两个元素的<strong>yAxisIndex</strong>指向<strong>yAxis</strong>的目标下标即可。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">option = &#123;</div><div class="line">    yAxis: [</div><div class="line">        &#123;</div><div class="line">            type: <span class="string">'value'</span>,</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            type: <span class="string">'value'</span>,</div><div class="line">        &#125;</div><div class="line">    ],</div><div class="line">    series: [&#123;</div><div class="line">        yAxisIndex:<span class="number">0</span>,</div><div class="line">        data: [<span class="number">0.820</span>, <span class="number">0.932</span>, <span class="number">0.901</span>, <span class="number">0.934</span>, <span class="number">0.1290</span>, <span class="number">0.1330</span>, <span class="number">0.1320</span>],</div><div class="line">        type: <span class="string">'line'</span></div><div class="line">    &#125;,&#123;</div><div class="line">        yAxisIndex:<span class="number">1</span>,</div><div class="line">        data: [<span class="number">820</span>, <span class="number">932</span>, <span class="number">901</span>, <span class="number">934</span>, <span class="number">1290</span>, <span class="number">1330</span>, <span class="number">1320</span>],</div><div class="line">        type: <span class="string">'line'</span></div><div class="line">    &#125;]</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="如何设置-Y-轴不存边框线，并且刻度值在刻度线上"><a href="#如何设置-Y-轴不存边框线，并且刻度值在刻度线上" class="headerlink" title="如何设置 Y 轴不存边框线，并且刻度值在刻度线上"></a>如何设置 Y 轴不存边框线，并且刻度值在刻度线上</h2><ul>
<li><p>效果如下：<br><img src="media/15210132803835/15210139637827.jpg" alt=""></p>
</li>
<li><p>解决方法：配置<strong>yAxis</strong>中<strong>yAxis.axisLine.show</strong>属性和<strong>yAxis.axisTick</strong>属性就可以让 Y 轴不显示边框线了，控制刻度值是通过<strong>yAxis.axisLabel</strong>来控制的。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">option = &#123;</div><div class="line">    yAxis:&#123;</div><div class="line">        type: <span class="string">'value'</span>,</div><div class="line">        axisTick: <span class="literal">false</span>,    <span class="comment">// 控制 Y 轴边框向里突出的那个东西是否显示</span></div><div class="line">        scale: <span class="literal">true</span>,</div><div class="line">        axisLabel: &#123;</div><div class="line">          margin: <span class="number">0</span>,</div><div class="line">          show: <span class="literal">true</span>,</div><div class="line">          inside: <span class="literal">true</span>,</div><div class="line">          color: <span class="string">'#999999'</span>,</div><div class="line">          verticalAlign: <span class="string">'bottom'</span></div><div class="line">        &#125;,</div><div class="line">        axisLine: &#123;         <span class="comment">// 控制 Y 轴边框是否显示</span></div><div class="line">          show: <span class="literal">false</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="如何设置折线图上存在指示图标，并且指示图标样式可以自定义"><a href="#如何设置折线图上存在指示图标，并且指示图标样式可以自定义" class="headerlink" title="如何设置折线图上存在指示图标，并且指示图标样式可以自定义"></a>如何设置折线图上存在指示图标，并且指示图标样式可以自定义</h2><ul>
<li><p>效果如下<br><img src="media/15210132803835/15210146965612.jpg" alt=""></p>
</li>
<li><p>解决方法：设置<strong>markPoint</strong>控制，<strong>markPoint.symbolSize</strong>可以设置指示图标的大小，<strong>markPoint.itemStyle.normal.formatter</strong>可以自定义设置图标内容，通过设置<strong>markPoint.data[i].xAxis</strong>控制图标X轴位置，通过设置<strong>markPoint.data[i].yAxis</strong>控制图标Y轴位置，设置<strong>markPoint.data[i].value</strong>当做<strong>formatter</strong>中param参数的value值，来自定义内容，<strong>itemStyle.normal.color</strong>可以设置指示图标的背景颜色，<strong>label</strong>可以设置目标指示图标的样式和偏移量等。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">option = &#123;</div><div class="line">  markPoint: &#123;</div><div class="line">    symbolSize: [<span class="number">30</span>, <span class="number">30</span>],</div><div class="line">    itemStyle: &#123;</div><div class="line">      normal: &#123;</div><div class="line">        label: &#123;</div><div class="line">          show: <span class="literal">true</span>,</div><div class="line">          formatter: <span class="function"><span class="keyword">function</span>(<span class="params">param</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (param.value == <span class="number">1</span>)</div><div class="line">              <span class="keyword">return</span> <span class="string">'S'</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">              <span class="keyword">return</span> <span class="string">'B'</span>;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    data: [&#123;</div><div class="line">      xAxis: <span class="string">'2012-12-12'</span>,</div><div class="line">      yAxis: <span class="number">30</span>,</div><div class="line">      name: <span class="string">'波峰'</span>,</div><div class="line">      value: <span class="number">0</span>,</div><div class="line">      itemStyle: &#123;</div><div class="line">        normal: &#123;</div><div class="line">          color: <span class="string">'#FEB4B2'</span></div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;, &#123;</div><div class="line">      xAxis: <span class="string">'2012-12-13'</span>,</div><div class="line">      yAxis: <span class="number">40</span>,</div><div class="line">      name: <span class="string">'波谷'</span>,</div><div class="line">      symbolRotate: <span class="number">180</span>,</div><div class="line">      value: <span class="number">1</span>,</div><div class="line">      itemStyle: &#123;</div><div class="line">        normal: &#123;</div><div class="line">          color: <span class="string">'#C1E476'</span></div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">      label: &#123;</div><div class="line">        normal: &#123;</div><div class="line">          offset: [<span class="number">0</span>, <span class="number">5</span>]</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="如何精确设置折线图上圆点的数量，并且控制每个点的样式还不一样"><a href="#如何精确设置折线图上圆点的数量，并且控制每个点的样式还不一样" class="headerlink" title="如何精确设置折线图上圆点的数量，并且控制每个点的样式还不一样"></a>如何精确设置折线图上圆点的数量，并且控制每个点的样式还不一样</h2><ul>
<li>效果如下：</li>
</ul>
<p><img src="media/15210132803835/15210155972648.jpg" alt=""></p>
<ul>
<li>解决方法：通过设置<strong>series</strong>中<strong>symbolSize</strong>可以控制小圆圈的大小，通过控制<strong>data</strong>中每一个<strong>value</strong>可以设置 Y 轴的位置，设置<strong>itemStyle</strong>可以控制图上每一个小圆点的样式，<strong>itemStyle.normal.opacity</strong>用来我们控制该圆点是否需要显示（这种方式是因为 X 轴置信只显示了两个坐标刻度，小圆点是根据刻度来的，所以只能显示所有刻度，然后有些隐藏而已），<strong>itemStyle.normal.opacity.borderColor</strong>就可以精确控制每一个小圆点不同样式了。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">option = &#123;</div><div class="line">  series: [&#123;</div><div class="line">    type: <span class="string">'line'</span>,</div><div class="line">    symbolSize: <span class="number">15</span>,</div><div class="line">    data: [&#123;</div><div class="line">      value: <span class="number">820</span>,</div><div class="line">      itemStyle: &#123;</div><div class="line">        normal: &#123;</div><div class="line">          opacity: <span class="number">1</span>, <span class="comment">// 控制是否显示折线上的该点小圆点</span></div><div class="line">          borderColor: <span class="string">'#6C9C39'</span> <span class="comment">// 控制显示某一个折线上该点小圆点的颜色</span></div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;, &#123;</div><div class="line">      value: <span class="number">620</span>,</div><div class="line">      itemStyle: &#123;</div><div class="line">        normal: &#123;</div><div class="line">          opacity: <span class="number">0</span>, <span class="comment">// 控制是否显示折线上的该点小圆点</span></div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;, &#123;</div><div class="line">      value: <span class="number">420</span>,</div><div class="line">      itemStyle: &#123;</div><div class="line">        normal: &#123;</div><div class="line">          opacity: <span class="number">1</span>, <span class="comment">// 控制是否显示折线上的该点小圆点</span></div><div class="line">          borderColor: <span class="string">'#6C9C39'</span> <span class="comment">// 控制显示某一个折线上该点小圆点的颜色</span></div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;, ]</div><div class="line">  &#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="如何精确控制-X-轴的显示刻度有多少个"><a href="#如何精确控制-X-轴的显示刻度有多少个" class="headerlink" title="如何精确控制 X 轴的显示刻度有多少个"></a>如何精确控制 X 轴的显示刻度有多少个</h2><ul>
<li>效果如下：</li>
</ul>
<p><img src="media/15210132803835/15210164719568.jpg" alt=""></p>
<ul>
<li>解决方法：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">option = &#123;</div><div class="line">  xAxis: &#123;</div><div class="line">    type: <span class="string">'category'</span>,</div><div class="line">    show: <span class="literal">true</span>,</div><div class="line">    splitLine: <span class="literal">false</span>,   <span class="comment">// 不显示X 轴刻度线</span></div><div class="line">    axisLabel: &#123;</div><div class="line">      interval: <span class="number">0</span>, <span class="comment">// 强制控制显示所有的圆点（不会被自动控制）</span></div><div class="line">      padding: [<span class="number">0</span>, <span class="number">60</span>, <span class="number">0</span>, <span class="number">0</span>], <span class="comment">// 控制 X 轴padding值</span></div><div class="line">      color: <span class="string">'#999999'</span>,       <span class="comment">// X 轴刻度值颜色</span></div><div class="line">      formatter: <span class="function"><span class="keyword">function</span>(<span class="params">value, index</span>) </span>&#123; <span class="comment">// 精确控制是否显示刻度值</span></div><div class="line">        <span class="keyword">if</span> (index == <span class="number">0</span> || index == (klineDataLength - <span class="number">1</span>)) &#123;</div><div class="line">          value = value.slice(<span class="number">0</span>, <span class="number">4</span>) + <span class="string">'-'</span> + value.slice(<span class="number">4</span>, <span class="number">6</span>) + <span class="string">'-'</span> + value.slice(<span class="number">6</span>, <span class="number">8</span>);</div><div class="line">          <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">'                                   '</span> + value;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">return</span> value;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="string">''</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    data: [<span class="string">'20121212'</span>, <span class="string">'20121213'</span>, <span class="string">'20121214'</span>, <span class="string">'20121215'</span>, <span class="string">'20121216'</span>]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="如何给图表设置指示线"><a href="#如何给图表设置指示线" class="headerlink" title="如何给图表设置指示线"></a>如何给图表设置指示线</h2><ul>
<li>效果如下：</li>
</ul>
<p><img src="media/15210132803835/15210168619095.jpg" alt=""></p>
<ul>
<li>解决方法：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">option = &#123;</div><div class="line">  series: [&#123;</div><div class="line">    type: <span class="string">'line'</span>,</div><div class="line">    markLine: &#123;</div><div class="line">      symbol: [<span class="string">'none'</span>, <span class="string">'none'</span>],</div><div class="line">      label: &#123;</div><div class="line">        normal: &#123;</div><div class="line">          position: <span class="string">'middle'</span>  <span class="comment">// 统一设置线上名称的位置</span></div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">      data: [&#123;  <span class="comment">// 设置线的条数</span></div><div class="line">          yAxis: <span class="number">20</span>,</div><div class="line">          lineStyle: &#123;  <span class="comment">// 设置线的样式</span></div><div class="line">            normal: &#123;</div><div class="line">              type: <span class="string">'solid'</span>,</div><div class="line">              color: <span class="string">'#FF5B5C'</span></div><div class="line">            &#125;</div><div class="line">          &#125;,</div><div class="line">          label: &#123;      <span class="comment">// 设置线上名称和其样式</span></div><div class="line">            show: <span class="literal">true</span>,</div><div class="line">            normal: &#123;</div><div class="line">              formatter: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="string">'过热'</span></div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;, &#123;</div><div class="line">          yAxis: <span class="number">30</span>,</div><div class="line">          lineStyle: &#123;</div><div class="line">            normal: &#123;</div><div class="line">              type: <span class="string">'solid'</span>,</div><div class="line">              color: <span class="string">'#6BACFC'</span></div><div class="line">            &#125;</div><div class="line">          &#125;,</div><div class="line">          label: &#123;</div><div class="line">            show: <span class="literal">true</span>,</div><div class="line">            normal: &#123;</div><div class="line">              formatter: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="string">'过冷'</span></div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  &#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="如何设置图表内容全部展示的同时自适应布局"><a href="#如何设置图表内容全部展示的同时自适应布局" class="headerlink" title="如何设置图表内容全部展示的同时自适应布局"></a>如何设置图表内容全部展示的同时自适应布局</h2><ul>
<li>解决方法：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">option = &#123;</div><div class="line">  grid: &#123;</div><div class="line">    top: <span class="number">20</span>,</div><div class="line">    bottom: <span class="number">10</span>,</div><div class="line">    left: <span class="number">0</span>,</div><div class="line">    right: <span class="number">5</span>,</div><div class="line">    containLabel: <span class="literal">true</span>, <span class="comment">// 当设置为true时会把所有的内容的包含进去再自适应布局布局</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> echarts </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[理解CSS中的层叠上下文和层叠顺序]]></title>
      <url>/2017/08/22/%E7%90%86%E8%A7%A3CSS%E4%B8%AD%E7%9A%84%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%B1%82%E5%8F%A0%E9%A1%BA%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h2 id="什么是层叠上下文（stacking-context）"><a href="#什么是层叠上下文（stacking-context）" class="headerlink" title="什么是层叠上下文（stacking context）"></a>什么是层叠上下文（stacking context）</h2><ul>
<li>可以理解为一个dom节点在Z轴高人一等，特性类似于<strong>BFC</strong>，即层叠上下文的内部子元素再怎么翻江倒海，翻云覆雨都不会影响外部的元素。</li>
</ul>
<h2 id="CSS2创建层叠上下文的两种方法（参考MDN）"><a href="#CSS2创建层叠上下文的两种方法（参考MDN）" class="headerlink" title="CSS2创建层叠上下文的两种方法（参考MDN）"></a>CSS2创建层叠上下文的两种方法（参考MDN）</h2><ul>
<li>根元素 (HTML)</li>
<li>绝对（absolute）定位或相对（relative）定位且 z-index 值不为”auto”</li>
</ul>
<h2 id="CSS3新增的8种方法（参考MDN）"><a href="#CSS3新增的8种方法（参考MDN）" class="headerlink" title="CSS3新增的8种方法（参考MDN）"></a>CSS3新增的8种方法（参考MDN）</h2><ul>
<li>一个 flex 元素(flex item)，且 z-index 值不为 “auto”，也就是父元素 display: flex|inline-flex</li>
<li>元素的 opacity 属性值小于 1（参考：<a href="https://www.w3.org/TR/css3-color/#transparency" target="_blank" rel="external">the specification for opacity</a>）</li>
<li>元素的 transform 属性值不为 “none”</li>
<li>元素的 mix-blend-mode 属性值不为 “normal”</li>
<li>元素的 isolation 属性被设置为 “isolate”</li>
<li>在 mobile WebKit 和 Chrome 22+ 内核的浏览器中，position: fixed 总是创建一个新的层叠上下文, 即使 z-index 的值是 “auto”</li>
<li>在 will-change 中指定了任意 CSS 属性，即便你没有定义该元素的这些属性（参考：<a href="https://dev.opera.com/articles/css-will-change-property/" target="_blank" rel="external">Everything You Need to Know About the CSS will-change Property</a>）</li>
<li>元素的 -webkit-overflow-scrolling 属性被设置 “touch”</li>
</ul>
<h2 id="什么是层叠水平（stacking-level）"><a href="#什么是层叠水平（stacking-level）" class="headerlink" title="什么是层叠水平（stacking level）"></a>什么是层叠水平（stacking level）</h2><ul>
<li>层叠水平决定了<strong>同一个层叠上下文中元素在z轴上的显示顺序（层叠顺序）</strong>，也就是说普通元素的层叠水平优先由层叠上下文决定。</li>
</ul>
<h2 id="层叠顺序（不包含CSS3属性）"><a href="#层叠顺序（不包含CSS3属性）" class="headerlink" title="层叠顺序（不包含CSS3属性）"></a>层叠顺序（不包含CSS3属性）</h2><p><img src="http://www.w3help.org/zh-cn/kb/013/stacklevel.png" alt=""></p>
<h6 id="注意：以上只适用于同一个层级上下文"><a href="#注意：以上只适用于同一个层级上下文" class="headerlink" title="注意：以上只适用于同一个层级上下文"></a>注意：以上只适用于同一个层级上下文</h6><h2 id="层叠顺序的例子"><a href="#层叠顺序的例子" class="headerlink" title="层叠顺序的例子"></a>层叠顺序的例子</h2><p><a href="https://repl.it/NcWU/4" target="_blank" rel="external">CSS2层叠上下文的层叠顺序demo</a><br><img src="media/15095911824790/15096064713504.jpg" alt=""></p>
<h2 id="创建层叠上下文的opacity影响层叠顺序的例子"><a href="#创建层叠上下文的opacity影响层叠顺序的例子" class="headerlink" title="创建层叠上下文的opacity影响层叠顺序的例子"></a>创建层叠上下文的opacity影响层叠顺序的例子</h2><p><a href="https://repl.it/Nc1n/4" target="_blank" rel="external">验证css中opacity创建层叠上下文影响的层叠顺序demo</a><br><img src="media/15095911824790/15096096002490.jpg" alt=""></p>
<h2 id="层叠准则"><a href="#层叠准则" class="headerlink" title="层叠准则"></a>层叠准则</h2><ul>
<li><strong>谁大谁上：</strong>当具有明显的层叠水平标识（即上面那幅层叠顺序图）的时候，在同一个层叠上下文内，层叠水平值大的那一个覆盖小的那一个。</li>
<li><strong>后来居上：</strong>当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul>
<li>属于同一层叠上下文的元素（无论它们在结构上是兄弟或父子，甚至是祖孙），都遵循上文所述的层叠顺序；</li>
<li>不同的层叠上下文之间，层级较大的层叠上下文元素及其内部元素位于层级小的层叠上下文元素及其内部元素之上；</li>
<li>不同的层叠上下文之间互相独立；</li>
<li>层叠上下文可嵌套，内部规则不影响外部。</li>
</ul>
<h2 id="相关连接"><a href="#相关连接" class="headerlink" title="相关连接"></a>相关连接</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context" target="_blank" rel="external">MDN：The stacking context</a><br><a href="http://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/" target="_blank" rel="external">深入理解CSS中的层叠上下文和层叠顺序</a><br><a href="https://aotu.io/notes/2015/11/08/css-stack-order/index.html" target="_blank" rel="external">css层叠顺序探究</a><br><a href="http://www.w3help.org/zh-cn/kb/013" target="_blank" rel="external">分层的显示</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 层叠水平 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS实现一个scroll自定义滚动效果]]></title>
      <url>/2017/08/22/%E9%97%AD%E5%8C%85%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
      <content type="html"><![CDATA[<p>在公司开发项目的时候，原生滚动条中有些东西没办法自定义去精细的控制，于是开发一个类似于better-scroll一样的浏览器滚动监听的JS实现，下面我们就来探究一下自定义滚动需要考虑哪些东西，经过哪些过程。</p>
<p>##选择滚动监听的事件<br>因为是自定义手机端的滚动事件，那我选择的是监听手机端的三个touch事件来实现监听，并实现了两种滚动效果，一种是通过-webkit-transform，一种是通过top属性。两种实现对于滚动的基本效果够能达到，可是top的不适合滚动中还存在滚动，可是能解决滚动中存在postion:fixed属性的问题；而transform可以实现滚动中有滚动，可是又不能解决postion:fixed的问题，所以，最后选择性考虑使用哪一种实现方式，用法一样。</p>
<p>##主要的实现业务逻辑</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">handleTouchMove(event)&#123;</div><div class="line">    event.preventDefault();</div><div class="line">    <span class="keyword">this</span>.currentY = event.targetTouches[<span class="number">0</span>].screenY;</div><div class="line">    <span class="keyword">this</span>.currentTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</div><div class="line">    <span class="comment">// 二次及以上次数滚动（间歇性滚动）时间和路程重置计算，0.05是间歇性滚动的停顿位移和时间比</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(<span class="keyword">this</span>.currentY - <span class="keyword">this</span>.lastY) / <span class="built_in">Math</span>.abs(<span class="keyword">this</span>.currentTime - <span class="keyword">this</span>.lastTime) &lt; <span class="number">0.05</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</div><div class="line">        <span class="keyword">this</span>.resetY = <span class="keyword">this</span>.currentY;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.distance = <span class="keyword">this</span>.currentY - <span class="keyword">this</span>.startY;</div><div class="line">    <span class="keyword">let</span> temDis = <span class="keyword">this</span>.distance + <span class="keyword">this</span>.oldY;</div><div class="line">    <span class="comment">/*设置移动最小值*/</span></div><div class="line">    temDis = temDis &gt; <span class="keyword">this</span>.minValue ? temDis * <span class="number">1</span> / <span class="number">3</span> : temDis;</div><div class="line">    <span class="comment">/*设置移动最大值*/</span></div><div class="line">    temDis = temDis &lt; -<span class="keyword">this</span>.maxValue ? -<span class="keyword">this</span>.maxValue + (temDis + <span class="keyword">this</span>.maxValue) * <span class="number">1</span> / <span class="number">3</span> : temDis;</div><div class="line">    <span class="keyword">this</span>.$el.style[<span class="string">"top"</span>] = temDis + <span class="string">'px'</span>;</div><div class="line">    <span class="keyword">this</span>.lastY = <span class="keyword">this</span>.currentY;</div><div class="line">    <span class="keyword">this</span>.lastTime = <span class="keyword">this</span>.currentTime;</div><div class="line">    <span class="keyword">this</span>.dispatchEvent();</div><div class="line">    <span class="keyword">this</span>.scrollFunc(event);</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p><strong>代码解读：</strong>这是监听touchmove事件的回调，其中主要计算出目标节点<strong>this.$el</strong>的<strong>top</strong>或者-webkit-transform中<strong>translateY</strong>的值，而计算的参考主要以事件节点的screenY的垂直移动距离为参考，当然其中还要判断一下最大值和最小值，为了保证移动可以的超出最大值小值一定的距离所以加了一个<strong>1/3</strong>的移动计算。这里可能主要到了有一个<strong>间歇性滚动</strong>的判断和计算，主要是服务于<strong>惯性滚动</strong>的，目的是让惯性滚动的值更加精确。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">handleTouchEnd(event)&#123;</div><div class="line">    <span class="comment">/*点透事件允许通过*/</span></div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.distance) <span class="keyword">return</span>;</div><div class="line">    event.preventDefault();</div><div class="line">    <span class="keyword">let</span> temDis = <span class="keyword">this</span>.distance + <span class="keyword">this</span>.oldY;</div><div class="line">    <span class="comment">/*计算缓动值*/</span></div><div class="line">    temDis = <span class="keyword">this</span>.computeSlowMotion(temDis);</div><div class="line">    <span class="comment">/*设置最小值*/</span></div><div class="line">    temDis = temDis &gt; <span class="keyword">this</span>.minValue ? <span class="keyword">this</span>.minValue : temDis;</div><div class="line">    <span class="comment">/*设置最大值*/</span></div><div class="line">    temDis = temDis &lt; -<span class="keyword">this</span>.maxValue ? -<span class="keyword">this</span>.maxValue : temDis;</div><div class="line">    <span class="keyword">this</span>.$el.style[<span class="string">"transitionDuration"</span>] = <span class="string">'500ms'</span>;</div><div class="line">    <span class="keyword">this</span>.$el.style[<span class="string">"transitionTimingFunction"</span>] = <span class="string">'ease-out'</span>;</div><div class="line">    <span class="comment">/*确定最终的滚动位置*/</span></div><div class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</div><div class="line">        <span class="keyword">this</span>.$el.style[<span class="string">"top"</span>] = temDis + <span class="string">'px'</span>;</div><div class="line">    &#125;, <span class="number">0</span>);</div><div class="line">    <span class="comment">// 判断使用哪一种监听事件</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.slowMotionFlag) &#123;</div><div class="line">        <span class="keyword">this</span>.dispatchEventLoop();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">this</span>.dispatchEvent();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.$el.addEventListener(<span class="string">'transitionend'</span>, ()=&gt; &#123;</div><div class="line">        <span class="built_in">window</span>.cancelAnimationFrame(<span class="keyword">this</span>.timer);</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">this</span>.scrollFunc(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>代码解读：</strong>这是touchend事件监听的回调，其中这里要判断是否要拦截click和tap事件，并且这里还要计算<strong>惯性缓动值</strong>，设置最终的最大最小值，以及设置动画效果和缓动效果。下面来谈一下滚性滚动的计算：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 计算惯性滚动值</span></div><div class="line">computeSlowMotion(temDis)&#123;</div><div class="line">    <span class="keyword">var</span> duration = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - <span class="keyword">this</span>.startTime;</div><div class="line">    <span class="comment">// 300毫秒是判断间隔的最佳时间</span></div><div class="line">    <span class="keyword">var</span> resetDistance = <span class="keyword">this</span>.currentY - <span class="keyword">this</span>.resetY;</div><div class="line">    <span class="keyword">if</span> (duration &lt; <span class="number">300</span> &amp;&amp; <span class="built_in">Math</span>.abs(resetDistance) &gt; <span class="number">10</span>) &#123;</div><div class="line">        <span class="keyword">var</span> speed = <span class="built_in">Math</span>.abs(resetDistance) / duration,</div><div class="line">            destination;</div><div class="line">        <span class="comment">// 末速度为0 距离等于初速度的平方除以2倍加速度</span></div><div class="line">        destination = (speed * speed) / (<span class="number">2</span> * <span class="keyword">this</span>.deceleration) * (resetDistance &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>);</div><div class="line">        <span class="keyword">this</span>.slowMotionFlag = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">return</span> temDis += destination;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">this</span>.slowMotionFlag = <span class="literal">false</span>;</div><div class="line">        <span class="keyword">return</span> temDis;</div><div class="line">    &#125;</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p><strong>代码解读</strong>：滚性滚动的算法主要是根据一个路程和时间计算出初速度，以及原生滚动的加速度的大于值0.006来计算滚动的总位移。这里主要还要判断一下一个300ms的经验值。</p>
<p>##总结<br>大概的流程和思考就是这样了，后续还会增加更多的功能进行扩展，下面附上git地址：<a href="https://github.com/yejiaming/scroll" target="_blank" rel="external">https://github.com/yejiaming/scroll</a></p>
]]></content>
      
        
        <tags>
            
            <tag> scroll </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES5和ES6作用域]]></title>
      <url>/2017/08/22/ES5%E5%92%8CES6%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<h1 id="ES5和ES6作用域"><a href="#ES5和ES6作用域" class="headerlink" title="ES5和ES6作用域"></a>ES5和ES6作用域</h1><p>##ES5的块级作用域</p>
<p>####ES5的块级作用域是一个伪块级作用域，代码块：{}，它的块里面和块外面都是共用一个作用域，即：<br><strong>Example:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="keyword">var</span> a =<span class="number">3</span>;</div><div class="line">	<span class="built_in">console</span>.log(a); <span class="comment">//结果为3   </span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">//结果为3</span></div></pre></td></tr></table></figure>
<p><strong>Example:</strong><br>ES5的伪块级作用域另外一个典型的例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">	a.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(i);</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line">a[<span class="number">0</span>](); <span class="comment">//预期结果是0，实际结果是10</span></div></pre></td></tr></table></figure>
<p><strong><em>注意</em></strong>：出现上述现象的主要原因是使用var定义的变量 <em>i</em> 是一个全局变量，导致真正在调用的时候虽然循环了10次，可是最终十次都是只修改了全局变量 <em>i</em> ,并没有区分出私有作用域。与之相反的两个例子如下：<br><a id="more"></a><br><strong><em>Example1</em></strong>： 这个是利用ES6的let申明的变量会限制在当前块级作用域内,每次重新申明了变量，申明了10次</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a =[];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">	a.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(i);</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line">a[<span class="number">0</span>](); <span class="comment">//结果为10</span></div></pre></td></tr></table></figure>
<p><strong><em>Example2</em></strong>： 这个是利用构建闭包来生成私有作用域</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">	a.push((<span class="function"><span class="keyword">function</span>(<span class="params">$i</span>)</span>&#123;<span class="comment">//$i是该匿名函数的入参，等同下面的i</span></div><div class="line">		<span class="function"><span class="keyword">function</span> <span class="title">k</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="built_in">console</span>.log($i);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span>  k;</div><div class="line">	&#125;)(i));</div><div class="line">&#125;</div><div class="line">a[<span class="number">0</span>](); <span class="comment">//结果为0</span></div></pre></td></tr></table></figure>
<p><strong><em>注意</em></strong>：如果上面的Example2不使用<strong>参数传递</strong>的方式创建<strong>私有作用域</strong>，那也可以<strong>内部定义变量</strong>的方式来代替，值得注意的是如果是直接引用外部变量创建的结果最终是一个空作用域，并不能达到隔变量 <em>i</em> 的效果<br><strong><em>Example3</em></strong>:错误例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">	a.push((<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//$i是该匿名函数的入参，等同下面的i</span></div><div class="line">		<span class="function"><span class="keyword">function</span> <span class="title">k</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="built_in">console</span>.log(i);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span>  k;</div><div class="line">	&#125;)());</div><div class="line">&#125;</div><div class="line">a[<span class="number">0</span>](); <span class="comment">//结果为10</span></div></pre></td></tr></table></figure>
<p>####ES5中的块级作用域有效的只有try catch，如：<br><strong>Example:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">	<span class="keyword">throw</span> <span class="number">3</span>;</div><div class="line">&#125;<span class="keyword">catch</span>(e)&#123;</div><div class="line">	<span class="built_in">console</span>.log(e); <span class="comment">//结果为3</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(e); <span class="comment">//结果为ReferenceError</span></div></pre></td></tr></table></figure>
<p><strong><em>注意</em></strong>：正因为try catch有如上的功能，所以有时候有些框架为了区分块级 <em>私有</em> 作用域就是用它来解决的，例如google的Traceur项目。</p>
<p><strong><strong>综上所述</strong></strong>：ES5伪块级作用域的问题是没有创建私有作用域，污染了它的父级甚至可能是全局作用域覆盖window对象的原生方法或属性。</p>
<p>##ES5函数作用域<br>ES5虽然不存在真正意义上的块级作用域，但是存在函数作用域，为了解决上述ES5伪块级作用域的问题，使用函数解决法如下：<br><strong><em>Exapmle1</em></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> a = <span class="number">5</span>;</div><div class="line">	<span class="built_in">console</span>.log(a); <span class="comment">//结果为5</span></div><div class="line">&#125;</div><div class="line">fun();</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">//结果为1</span></div></pre></td></tr></table></figure>
<p><strong><em>注意</em></strong>：以上生成函数作用域的写法存在两个问题，第一：申明了全局的具名函数fun，污染了全局作用域。第二：如果要实现这个私有作用域，必须要函数调用才行。</p>
<p><strong><em>Example2</em></strong>：改良上述两个问题的写法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> a =<span class="number">5</span>;</div><div class="line">	<span class="built_in">console</span>.log(a); <span class="comment">//结果为5</span></div><div class="line">&#125;)();</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">//结果为1</span></div></pre></td></tr></table></figure>
<p><strong><em>注意</em></strong>：例子2的写法在JS社区规定的术语是<strong>立即执行函数表达式</strong>——IIFE，它可以<strong>无伤</strong>地创建一个<strong>块级私有作用域</strong>替代ES5的<strong>伪块级作用域</strong>，还有虽然它般用和闭包结合使用，但注意和闭包的区分。</p>
<p>####立即执行函数表达式另一个常用技巧<br>倒置立即执行函数代码的运行顺序，将需要运行的函数放在第二位，在立即执行函数执行之后当作参数传递进去。这种模式在UMD(Universal Module Definition)项目中被广泛使用。</p>
<p><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a=<span class="number">2</span>;</div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"> def </span>)</span>&#123; </div><div class="line">	def( <span class="built_in">window</span> );</div><div class="line">&#125;)(<span class="function"><span class="keyword">function</span> <span class="title">def</span>(<span class="params"> global </span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> a=<span class="number">3</span>;</div><div class="line">	<span class="built_in">console</span>.log( a ); <span class="comment">// 3  </span></div><div class="line">	<span class="built_in">console</span>.log(global.a); <span class="comment">//2</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong><em>代码解读</em></strong>：例子中将代码<strong>主体</strong>放在了立即执行函数的参数部分，当做参数传递给执行函数，执行函数的内部又立即调用了这个函数，并将全局的window对象当做参数传递给<strong>参数主体函数</strong>，并匿名window为global来调动全局a变量，达到不会与参数主体函数的作用域冲突。</p>
]]></content>
      
        
        <tags>
            
            <tag> 块级作用域 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[对ES5中apply、call和bind三个方法的解读]]></title>
      <url>/2017/08/21/%E5%AF%B9ES5%E4%B8%ADapply%E3%80%81call%E5%92%8Cbind%E4%B8%89%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E8%A7%A3%E8%AF%BB/</url>
      <content type="html"><![CDATA[<h1 id="ES6迭代器（interator）和for…of…循环"><a href="#ES6迭代器（interator）和for…of…循环" class="headerlink" title="ES6迭代器（interator）和for…of…循环"></a>ES6迭代器（interator）和for…of…循环</h1><p>或许在写ES6的代码的时候，你可能没有感觉有用过迭代器这个东西，可是ES6中的for…of…循环我们都不陌生，而for…of…循环的必要条件就是必须满足被循环的对象实现了迭代器接口才行。例子如下：</p>
<p><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> b = &#123;</div><div class="line">		name:<span class="string">'arvin'</span>,</div><div class="line">		age:<span class="number">30</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> a)&#123;</div><div class="line">		<span class="built_in">console</span>.log(i);     <span class="comment">// 结果依次是：1，2，3</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j <span class="keyword">of</span> b)&#123;</div><div class="line">		<span class="built_in">console</span>.log(j);     <span class="comment">// TypeError: b[Symbol.iterator] is not a function</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>代码解读：</strong>对于上面代码的结果我们基本都知道，可是为什么是这个结果就不会很懂了。从代码的结果可以看出，for…of…循环可行的条件是需要被循环对象实现一个以Symbol.iterator为方法属性才行。而数组对象是默认实现了该方法的，所以并未报错。现在我们就来具体实现一下这个迭代器接口。</p>
<p><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> b = &#123;</div><div class="line">		name:<span class="string">'arvin'</span>,</div><div class="line">		age:<span class="number">30</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">Object</span>.defineProperty(b, <span class="built_in">Symbol</span>.iterator, &#123;</div><div class="line">		enumerable: <span class="literal">false</span>,</div><div class="line">		writable: <span class="literal">false</span>,</div><div class="line">		configurable: <span class="literal">true</span>,</div><div class="line">		value: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">				<span class="keyword">var</span> me = <span class="keyword">this</span>;</div><div class="line">				<span class="keyword">var</span> idx = <span class="number">0</span>;</div><div class="line">				<span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(me);</div><div class="line">				<span class="keyword">return</span> &#123;</div><div class="line">						next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">								<span class="keyword">return</span> &#123;</div><div class="line">										value: me[keys[idx++]],</div><div class="line">										done: (idx &gt; keys.length)</div><div class="line">								&#125;</div><div class="line">						&#125;</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j <span class="keyword">of</span> b)&#123;</div><div class="line">		<span class="built_in">console</span>.log(j);     <span class="comment">// 结果依次是：arvin,30</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 下面的代码类似上面的for...of...循环的内部实现</span></div><div class="line"><span class="keyword">var</span> c = b[<span class="built_in">Symbol</span>.iterator]();</div><div class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">	<span class="keyword">var</span> newValue = c.next();</div><div class="line">	<span class="keyword">if</span>(newValue.done)&#123;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">console</span>.log(newValue.value)   <span class="comment">// 结果依次是：arvin,30</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>代码解读：</strong>从上面的这个demo可以看出，ES6的迭代器是<strong>实现要求必须要实现一个Symbol.iterator接口，并且该接口要返回一个带有next方法的对象，而且该next方法必须包含至少两个值，value以及done，前者是迭代器的输出值，后者是判断迭代终止条件。</strong>下面附上一个通用上传迭代器的运用例子：</p>
<p><strong>Example</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> getUploadObj = &#123;</div><div class="line">		getActiveUploadObj ()&#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">						<span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="string">'TXFTNActiveX.FTNUpload'</span>);   <span class="comment">// IE上传控件</span></div><div class="line">				&#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">						<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">				&#125;</div><div class="line">		&#125;,</div><div class="line">		getFalshUploadObj () &#123;  </div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">						<span class="keyword">new</span> ActiveXObject(<span class="string">'ShockwaveFlash.ShockwaveFlash'</span>);   <span class="comment">// Flash上传控件</span></div><div class="line">						<span class="keyword">let</span> str = <span class="string">'&lt;object type="application/x-shockwave-flash"&gt;&lt;/object&gt;'</span>;</div><div class="line">						<span class="keyword">return</span> $(str).appendTo($(<span class="string">'body'</span>));</div><div class="line">				&#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">						<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">				&#125;</div><div class="line">		&#125;,</div><div class="line">		getFormUploadObj () &#123;</div><div class="line">				<span class="keyword">let</span> str = <span class="string">'&lt;input name="file" type="file" calss="ui-file"/&gt;'</span>;   <span class="comment">// 表单上传</span></div><div class="line">				<span class="keyword">return</span> $(str).appendTo($(<span class="string">'body'</span>));</div><div class="line">		&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 给对象getUploadObj定义iterator接口，上面演示过这段代码</span></div><div class="line"><span class="comment">// 这里可以通过工厂模式，抽象成一个专门给对象安装iterator接口的函数，这样就可以省却很多重复代码了。</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(getUploadObj, <span class="built_in">Symbol</span>.iterator, &#123;</div><div class="line">		enumerable: <span class="literal">false</span>,</div><div class="line">		writable: <span class="literal">false</span>,</div><div class="line">		configurable: <span class="literal">true</span>,</div><div class="line">		value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">				<span class="keyword">var</span> o = <span class="keyword">this</span>;</div><div class="line">				<span class="keyword">var</span> idx = <span class="number">0</span>;</div><div class="line">				<span class="keyword">var</span> ks = <span class="built_in">Object</span>.keys(o);</div><div class="line">				<span class="keyword">return</span> &#123;</div><div class="line">						next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">								<span class="keyword">return</span> &#123;</div><div class="line">										value: o[ks[idx++]],</div><div class="line">										done: (idx &gt; ks.length)</div><div class="line">								&#125;</div><div class="line">						&#125;</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">iteratorUploadObj</span> (<span class="params">uploadObj</span>)</span>&#123;</div><div class="line">		<span class="comment">// 直接使用`for...of`遍历uploadObj对象</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">let</span> getUpload <span class="keyword">of</span> uploadObj)&#123;</div><div class="line">				<span class="keyword">let</span> uploadObj = getUpload();</div><div class="line">				<span class="keyword">if</span>(uploadObj) <span class="keyword">return</span> uploadObj;</div><div class="line">		&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> uploadObj = iteratorUploadObj(getUploadObj);</div><div class="line"><span class="built_in">console</span>.log(uploadObj);  <span class="comment">// [input, prevObject: Z.fn.init[1], context: undefined]</span></div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> call </tag>
            
            <tag> bind </tag>
            
            <tag> apply </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
